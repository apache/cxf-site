
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - WS-Security">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>
Apache CXF -- WS-Security
    </title>
  </head>
<body onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td id="cell-0-0" colspan="2">&nbsp;</td>
    <td id="cell-0-1">&nbsp;</td>
    <td id="cell-0-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-1-0">&nbsp;</td>
    <td id="cell-1-1">&nbsp;</td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight: bold; font-size: 170%; color: white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="The Apache Sofware Foundation"><img border="0" alt="ASF Logo" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs -->
<a href="index.html">Index</a>&nbsp;&gt;&nbsp;<a href="ws-support.html">WS-* Support</a>&nbsp;&gt;&nbsp;<a href="ws-security.html">WS-Security</a>
                <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">Download</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">Documentation</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </table>
      </div>
    </td>
    <td id="cell-1-3">&nbsp;</td>
    <td id="cell-1-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2">&nbsp;</td>
    <td id="cell-2-1">
      <table>
        <tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">Overview</a></li><li><a shape="rect" href="how-tos.html">How-Tos</a></li><li><a shape="rect" href="frontends.html">Frontends</a></li><li><a shape="rect" href="databindings.html">DataBindings</a></li><li><a shape="rect" href="transports.html">Transports</a></li><li><a shape="rect" href="configuration.html">Configuration</a></li><li><a shape="rect" href="debugging-and-logging.html">Debugging and Logging</a></li><li><a shape="rect" href="tools.html">Tools</a></li><li><a shape="rect" href="restful-services.html">RESTful Services</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL Bindings</a></li><li><a shape="rect" href="service-routing.html">Service Routing</a></li><li><a shape="rect" href="dynamic-languages.html">Dynamic Languages</a></li><li><a shape="rect" href="ws-support.html">WS-* Support</a></li><li><a shape="rect" href="advanced-integration.html">Advanced Integration</a></li><li><a shape="rect" href="deployment.html">Deployment</a></li><li><a shape="rect" href="schemas-and-namespaces.html">Use of Schemas and Namespaces</a></li></ul><hr><ul class="alternate"><li><p>Search</p></li></ul><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF Website</a></li></ul><p>&#160;</p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="WSSecurity-WS-Security">WS-Security</h1><p>WS-Security provides means to secure your services above and beyond transport level protocols such as HTTPS. Through a number of standards such as XML-Encryption, and headers defined in the WS-Security standard, it allows you to:</p><ul><li>Pass authentication tokens between services</li><li>Encrypt messages or parts of messages</li><li>Sign messages</li><li>Timestamp messages</li><li>Manage public keys using <a shape="rect" href="http://cxf.apache.org/docs/xml-key-management-service-xkms.html">XKMS</a></li></ul><p>CXF relies on <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j">WSS4J</a> in large part to implement WS-Security. Within your own services, WS-Security can be activated by using <a shape="rect" href="http://cxf.apache.org/docs/ws-securitypolicy.html">WS-SecurityPolicy</a>, which provides a comprehensive and sophisticated validation of the security properties of a received message. A non-WS-SecurityPolicy approach is usually also possible by way of CXF interceptors added to your service and/or client as detailed in this article.</p><p>Please note that there are some incompatibilities between WSS4J 1.6.x (used by Apache CXF 2.6.x and 2.7.x) and 2.0.x (used by Apache CXF 3.0.x and 3.1.x). The examples and links on this page mainly pertain to WSS4J 2.0.x and hence CXF 3.0.x. For more information on the changes in WSS4J 2.0.x please see the following <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/migration/wss4j20.html">migration page</a>.</p><h1 id="WSSecurity-Overviewofencryptionandsigning">Overview of encryption and signing</h1><p>WS-Security makes heavy use of public/private key cryptography. To really understand how to configure WS-Security, it is helpful - if not necessary - to understand these basics. The Wikipedia has an <a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/Public-key_cryptography" rel="nofollow">excellent entry</a> on this, but we'll try to summarize the relevant basics here (This content is a modified version of the wikipedia content..)</p><p>With public key cryptography, a user has a pair of public and private keys. These are generated using a large prime number and a key function.<br clear="none"> <span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Public_key_making.svg/250px-Public_key_making.svg.png" data-image-src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Public_key_making.svg/250px-Public_key_making.svg.png"></span></p><p>The keys are related mathematically, but cannot be derived from one another. With these keys we can encrypt messages. For example, if Bob wants to send a message to Alice, he can encrypt a message using her public key. Alice can then decrypt this message using her private key. Only Alice can decrypt this message as she is the only one with the private key.<br clear="none"> <span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Public_key_encryption.svg/280px-Public_key_encryption.svg.png" data-image-src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Public_key_encryption.svg/280px-Public_key_encryption.svg.png"></span></p><p>Messages can also be signed. This allows you to ensure the authenticity of the message. If Alice wants to send a message to Bob, and Bob wants to be sure that it is from Alice, Alice can sign the message using her private key. Bob can then verify that the message is from Alice by using her public key.<br clear="none"> <span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Public_key_signing.svg/280px-Public_key_signing.svg.png" data-image-src="http://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Public_key_signing.svg/280px-Public_key_signing.svg.png"></span></p><h1 id="WSSecurity-ConfiguringtheWSS4JInterceptors">Configuring the WSS4J Interceptors</h1><p>To enable WS-Security within CXF for a server or a client, you'll need to set up the WSS4J interceptors. You can either do this via the API for standalone web services or via Spring XML configuration for servlet-hosted ones. This section will provide an overview of how to do this, and the following sections will go into more detail about configuring the interceptors for specific security actions.</p><p>It is important to note that:</p><ol><li>If you are using CXF 2.0.x, you must add the SAAJ(In/Out)Interceptors if you're using WS-Security (This is done automatically for you from CXF 2.1 onwards). These enable creation of a DOM tree for each request/response. The support libraries for WS-Security require DOM trees.</li><li>The web service provider may not need both in and out WS-Security interceptors. For instance, if you are just requiring signatures on incoming messages, the web service provider will just need an incoming WSS4J interceptor and only the SOAP client will need an outgoing one.</li></ol><h2 id="WSSecurity-AddingtheinterceptorsviatheAPI">Adding the interceptors via the API</h2><p>On the Server side, you'll want to add the interceptors to your CXF Endpoint. If you're publishing your service using the JAX-WS APIs, you can get your CXF endpoint like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.jaxws.EndpointImpl;

EndpointImpl jaxWsEndpoint = (EndpointImpl) javax.xml.ws.Endpoint.publish("http://host/service", myServiceImpl);
Endpoint cxfEndpoint = jaxWsEndpoint.getServer().getEndpoint();
</pre>
</div></div><p>If you've used the (JaxWs)ServerFactoryBean, you can simply access it via the Server object:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.frontend.ServerFactoryBean;

ServerFactoryBean factory = ...;
...
Server server = factory.create();
Endpoint cxfEndpoint = server.getEndpoint();
</pre>
</div></div><p>On the client side, you can obtain a reference to the CXF endpoint using the ClientProxy helper:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.frontend.ClientProxy;
...

GreeterService gs = new GreeterService();
Greeter greeter = gs.getGreeterPort();
...
org.apache.cxf.endpoint.Client client = ClientProxy.getClient(greeter);
org.apache.cxf.endpoint.Endpoint cxfEndpoint = client.getEndpoint();
</pre>
</div></div><p><span class="confluence-anchor-link" id="WSSecurity-addinterceptors"></span>Now you're ready to add the interceptors:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor;
import org.apache.cxf.ws.security.wss4j.WSS4JOutInterceptor;
...

Map&lt;String,Object&gt; inProps = new HashMap&lt;String,Object&gt;();
... // how to configure the properties is outlined below;

WSS4JInInterceptor wssIn = new WSS4JInInterceptor(inProps);
cxfEndpoint.getInInterceptors().add(wssIn);

Map&lt;String,Object&gt; outProps = new HashMap&lt;String,Object&gt;();
... // how to configure the properties is outlined below;

WSS4JOutInterceptor wssOut = new WSS4JOutInterceptor(outProps);
cxfEndpoint.getOutInterceptors().add(wssOut);
</pre>
</div></div><h1 id="WSSecurity-SpringXMLConfiguration">Spring XML Configuration</h1><p>If you're using Spring to build endpoints (e.g., web services running on a servlet container such as Tomcat), you can easily accomplish the above using your bean definitions instead.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt;
&lt;import resource="classpath*:META-INF/cxf/cxf-extension-*.xml" /&gt;

&lt;jaxws:endpoint id="myService"
   implementor="com.acme.MyServiceImpl"
   address="http://localhost:9001/MyService"&gt;

   &lt;bean id="myPasswordCallback"
      class="com.mycompany.webservice.ServerPasswordCallback"/&gt;

   &lt;jaxws:inInterceptors&gt;
      &lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
         &lt;constructor-arg&gt;
            &lt;map&gt;
               &lt;entry key="action" value="UsernameToken"/&gt;
               &lt;entry key="passwordType" value="PasswordDigest"/&gt;
               &lt;entry key="signaturePropFile" value="..."/&gt;
               &lt;entry key="passwordCallbackRef"&gt;
                  &lt;ref bean="myPasswordCallback"/&gt;
               &lt;/entry&gt;
               ...
            &lt;/map&gt;
         &lt;/constructor-arg&gt;
      &lt;/bean&gt;
   &lt;/jaxws:inInterceptors&gt;
&lt;/jaxws:endpoint&gt;
</pre>
</div></div><p>The entry keys and values given in the constructor-arg element above (action, signaturePropFile, etc.) map to the text strings in WSS4J's <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/dom/handler/WSHandlerConstants.html">WSHandlerConstants</a> and <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/dom/WSConstants.html">WSConstants</a> classes for the corresponding WSHandlerConstants.XXXXX and WSConstants.XXXX constants you see in the section below (also see the WSS4J configuration <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/config.html">page</a>). So by viewing WSHandlerConstants, for example, you can see that the WSHandlerConstants.USERNAME_TOKEN value given below would need to be "UsernameToken" instead when doing Spring configuration.</p><p>If you want to avoid looking up the text keys for the WSHandlerConstants.XXXXX and WSConstants.XXXX constants, you can also use the Spring util namespace to reference static constants in your Spring context as shown below.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans
  ...
  xmlns:util="http://www.springframework.org/schema/util"
  ...
  xsi:schemaLocation="
        ...
        http://www.springframework.org/schema/util 
        http://www.springframework.org/schema/util/spring-util.xsd"&gt;

  ...

  &lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
    &lt;constructor-arg&gt;
      &lt;map&gt;
        &lt;entry value="UsernameToken"&gt;
          &lt;key&gt;
            &lt;util:constant 
                static-field="org.apache.wss4j.dom.handler.WSHandlerConstants.ACTION"/&gt;
          &lt;/key&gt;
        &lt;/entry&gt;
        ...
      &lt;/map&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;

  ...  
</pre>
</div></div><h2 id="WSSecurity-AdditionalConfigurationOptions">Additional Configuration Options</h2><p>While the CXF WSS4J interceptors support the standard configuration properties available in WSHandlerConstants.XXXXX and WSConstants.XXXX, CXF also provides access to some additional low level configuration capabilities in WSS4J and some other security related interceptors.</p><h3 id="WSSecurity-ValidatingSignatureand/orEncryptionofMessageContents">Validating Signature and/or Encryption of Message Contents</h3><p>As of CXF 2.2.8, the CryptoCoverageChecker interceptor allows one to validate signature and encryption coverage of message contents without migrating to a WS-SecurityPolicy based configuration. The interceptor can support enforcement of signature and encryption coverage at both the element and content level (be aware that the combination of signature and content do not represent a valid combination of coverage type and coverage scope). To configure this interceptor using the API, follow the example below.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.ws.security.wss4j.CryptoCoverageChecker;
import org.apache.cxf.ws.security.wss4j.CryptoCoverageChecker.XPathExpression;
import org.apache.cxf.ws.security.wss4j.CryptoCoverageUtil.CoverageScope;
import org.apache.cxf.ws.security.wss4j.CryptoCoverageUtil.CoverageType;

Map&lt;String, String&gt; prefixes = new HashMap&lt;String, String&gt;();
        prefixes.put("ser", "http://www.sdj.pl");
        prefixes.put("soap", "http://schemas.xmlsoap.org/soap/envelope/");

List&lt;XPathExpression&gt; xpaths = Arrays.asList(
    new XPathExpression("//ser:Header", CoverageType.SIGNED, 
        CoverageScope.ELEMENT),
    new XPathExpression("//soap:Body", CoverageType.ENCRYPTED, 
        CoverageScope.CONTENT));

CryptoCoverageChecker checker = new CryptoCoverageChecker(prefixes, xpaths);
</pre>
</div></div><p>The interceptor can also be configured in Spring using the conventional bean definition format.</p><p>After configuring the interceptor as above, simply add the interceptor to your client or server interceptor chain as shown previously with the WSS4J interceptors. Ensure that you include the WSS4JInInterceptor in the chain or all requests will be denied if you enforce any coverage XPaths.</p><p>The CryptoCoverageChecker is somewhat complex to set up for the most common use-cases for signature verification and decryption, as it involves adding XPath expressions and the corresponding prefix/namespace pairs. In Apache CXF 2.4.9, 2.5.5 and 2.6.2, a new subclass of CryptoCoverageChecker has been introduced. The DefaultCryptoCoverageChecker provides an easy way to ensure that the SOAP Body is signed or encrypted, that the Timestamp is signed, and that the WS-Addressing ReplyTo and FaultTo headers are signed (if they are present in the message payload).</p><p>The default configuation is that the SOAP Body, (WSU) Timestamp and WS-Addressing ReplyTo and FaultTo headers must be signed (if they exist in the message payload). This provides an out-of-the-box way of preventing XML Signature wrapping attacks. All that is required is that the DefaultCryptoCoverageChecker be added to the in-interceptor chain. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxws:inInterceptors&gt;
    &lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
        &lt;constructor-arg&gt;
            &lt;map&gt;
                &lt;entry key="action" value="Signature Timestamp"/&gt;
                &lt;entry key="signaturePropFile" value="..."/&gt;
                &lt;entry key="passwordCallbackClass"value="..."/&gt;
           &lt;/map&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean class="org.apache.cxf.ws.security.wss4j.DefaultCryptoCoverageChecker"/&gt;
&lt;/jaxws:inInterceptors&gt;
</pre>
</div></div><p>As of CXF 2.5.11, 2.6.8 and 2.7.5, it is possible to only check that a received message meets cryptographic requirements via the CryptoCoverageChecker if it is not a fault. This is useful in the scenario where a client is using the CryptoCoverageChecker interceptor to verify security requirements from a service response. In this scenario, you may want to get the original service Fault rather than have the CryptoCoverageChecker throw an exception if a Fault message from the service isn't secured. To enable this behaviour, then set the "checkFaults" boolean property on CryptoCoverageChecker to "false".</p><h3 id="WSSecurity-CustomProcessors">Custom Processors</h3><p>As of CXF 2.0.10 and 2.1.4, you can specify custom WSS4J Processor configurations on the WSS4JInInterceptor. To activate this configuration option, one provides a non-WSS4J defined property, wss4j.processor.map, to the WSS4JInInterceptor as shown in the following Spring example. The same configuration can be achieved through the API as well. The key value is an XML qualified name of the WS-Security header element to process with the given processor implementation. The entry values can be a String representing a class name of the processor to instantiate, an Object implementing Processor, or null to disable processing of the given WS-Security header element.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
  &lt;constructor-arg&gt;
    &lt;map&gt;
      ...
      &lt;!-- This reconfigures the processor implementation that WSS4j uses to 
               process a WS-Security Signature element. --&gt;
      &lt;entry key="wss4j.processor.map"&gt;
        &lt;map key-type="javax.xml.namespace.QName"&gt;
          &lt;entry value="my.class"&gt;
            &lt;key&gt;
              &lt;bean class="javax.xml.namespace.QName"&gt;
                &lt;constructor-arg value="http://www.w3.org/2000/09/xmldsig#"/&gt;
                &lt;constructor-arg value="Signature"/&gt;
              &lt;/bean&gt;
            &lt;/key&gt;
          &lt;/entry&gt;
        &lt;/map&gt;
      &lt;/entry&gt;
      ...
    &lt;/map&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre>
</div></div><h3 id="WSSecurity-CustomActions">Custom Actions</h3><p>As of CXF 2.2.6, you can specify custom WSS4J Action configurations on the WSS4JOutInterceptor. To activate this configuration option, one provides a non-WSS4J defined property, wss4j.action.map, to the WSS4JOutInterceptor as shown in the following Spring example. The same configuration can be achieved through the API as well. The key value is an integer representing the WSS4J action identifier. The entry values can be a String representing a class name of the action to instantiate or an Object implementing Action. This configuration option allows you to override built-in action implementations or add your own.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JOutInterceptor"&gt;
  &lt;constructor-arg&gt;
    &lt;map&gt;
      ...
      &lt;!-- Redefines the action for SAMLTokenSigned 
               to use a custom implementation.  --&gt;
      &lt;entry key="wss4j.action.map"&gt;
        &lt;map key-type="java.lang.Integer" value-type="java.lang.Object"&gt;
          &lt;entry key="0x10" value-ref="mySamlTokenSignedAction"/&gt;
        &lt;/map&gt;
      &lt;/entry&gt;      ...
    &lt;/map&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre>
</div></div><p>For the case that adding new custom action, if the new key int number is 12345, you must also specify new action name as string "12345".</p><h1 id="WSSecurity-ConfiguringWS-SecurityActions">Configuring WS-Security Actions</h1><h2 id="WSSecurity-UsernameTokenAuthentication">Username Token Authentication</h2><p>WS-Security supports many ways of specifying tokens. One of these is the UsernameToken header. It is a standard way to communicate a username and password or password digest to another endpoint. Be sure to review the OASIS <a shape="rect" class="external-link" href="http://tinyurl.com/65n78j" rel="nofollow">UsernameToken Profile Specification</a> for important security considerations when using UsernameTokens.</p><p>If a nonce is present in a UsernameToken then it should be cached by the message recipient to guard against replay attacks. This behaviour is enabled by default starting with CXF 2.6.0. This functionality is also available from Apache CXF 2.4.7 and 2.5.3 onwards, but is not enabled by default at all for backwards-compatibility reasons. The following properties control nonce caching:</p><ul><li>"ws-security.enable.nonce.cache" - Whether to cache UsernameToken nonces. The default value (for CXF 2.6.0) is "true" for message recipients, and "false" for message initiators. Set it to true to cache for both cases. The default value for CXF 2.4.x and 2.5.x is false. See <a shape="rect" href="http://cxf.apache.org/javadoc/latest/org/apache/cxf/ws/security/SecurityConstants.html#ENABLE_NONCE_CACHE">here</a> for more information.</li><li>"ws-security.nonce.cache.instance" - This holds a reference to a <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/cache/ReplayCache.html">ReplayCache</a> instance used to cache UsernameToken nonces. The default instance that is used is the <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/cache/EHCacheReplayCache.html">EHCacheReplayCache</a>.</li><li>"ws-security.cache.config.file" - Set this property to point to a configuration file for the underlying caching implementation. The default configuration file that is used is <a shape="rect" class="external-link" href="http://svn.apache.org/viewvc/cxf/trunk/rt/ws/security/src/main/resources/cxf-ehcache.xml?view=markup">cxf-ehcache.xml</a> in the cxf-rt-ws-security module.</li></ul><p>For the server side, you'll want to set up the following properties on your WSS4JInInterceptor (see <a shape="rect" href="ws-security.html">above</a> for code sample):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">inProps.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);
// Password type : plain text
inProps.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);
// for hashed password use:
//properties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);
// Callback used to retrieve password for given user.
inProps.put(WSHandlerConstants.PW_CALLBACK_CLASS, 
    ServerPasswordHandler.class.getName());
</pre>
</div></div><p>The password callback class allows you to retrieve the password for a given user so that WS-Security can determine if they're authorized. Here is a small example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.wss4j.common.ext.WSPasswordCallback;

public class ServerPasswordCallback implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException, 
        UnsupportedCallbackException {

        WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];

        if (pc.getIdentifier().equals("joe")) {
            // set the password on the callback. This will be compared to the
            // password which was sent from the client.
            pc.setPassword("password");
        }
    }

}
</pre>
</div></div><p>Note that for up to and including CXF 2.3.x, the password validation of the special case of a plain-text password (or any other yet unknown password type) is delegated to the callback class. In that case, the ServerPasswordCallback should be something like the following one:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class ServerPasswordCallback implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException, 
        UnsupportedCallbackException {

        WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];

        if (pc.getIdentifer().equals("joe") {
           if (!pc.getPassword().equals("password")) {
                throw new IOException("wrong password");
           }
        }
    }

}
</pre>
</div></div><p>For CXF 2.4 onwards, the callback handler supplies the password for all cases, and the validation is done internally (but can be configured). See <a shape="rect" class="external-link" href="http://coheigea.blogspot.com/2011/02/usernametoken-processing-changes-in.html" rel="nofollow">here</a> for more information.<br clear="none"> On the Client side you'll want to configure the WSS4J outgoing properties:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">outProps.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);
// Specify our username
outProps.put(WSHandlerConstants.USER, "joe");
// Password type : plain text
outProps.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);
// for hashed password use:
//properties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);
// Callback used to retrieve password for given user.
outProps.put(WSHandlerConstants.PW_CALLBACK_CLASS, 
    ClientPasswordHandler.class.getName());
</pre>
</div></div><p>Once again we're using a password callback, except this time instead of specifying our password on the server side, we're specifying the password we want sent with the message. This is so we don't have to store our password in our configuration file.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.wss4j.common.ext.WSPasswordCallback;

public class ClientPasswordCallback implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException, 
        UnsupportedCallbackException {

        WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];

        // set the password for our message.
        pc.setPassword("password");
    }

}
</pre>
</div></div><p>In the case of multiple users with different passwords, use the <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/ext/WSPasswordCallback.html">WSPasswordCallback</a>'s getIdentifier() method to obtain the username of the current SOAP request.</p><p><a shape="rect" class="external-link" href="http://depressedprogrammer.wordpress.com/2007/07/31/cxf-ws-security-using-jsr-181-interceptor-annotations-xfire-migration/" rel="nofollow">Here is an example</a> of WS-Security implemented using annotations for interceptors (uses UsernameToken).</p><h3 id="WSSecurity-WS-SecurityUsernameTokenandCustomAuthentication">WS-Security UsernameToken and Custom Authentication</h3><p>If needed, one may want to configure a jaxws:endpoint with a "ws-security.validate.token" property set to false and register a custom org.apache.cxf.interceptor.security.AbstractUsernameTokenInInterceptor implementation for using a WSS4J UsernameToken wrapped in a CXF specific UsernameToken for the custom authentication and Subject creation. The JAASLoginInterceptor will also recognize a CXF UsernameToken and thus can be used instead of the custom org.apache.cxf.interceptor.security.AbstractUsernameTokenInterceptor. (Prior to CXF 2.4.0, use "ws-security.ut.no-callbacks" instead of "ws-security.validate.token" with the value of true instead of false to postpone the validation of the token.)</p><h2 id="WSSecurity-UsingX.509Certificates">Using X.509 Certificates</h2><p>The X.509 Certificate Token Profile (<a shape="rect" class="external-link" href="http://www.oasis-open.org/committees/download.php/16785/wss-v1.1-spec-os-x509TokenProfile.pdf" rel="nofollow">pdf</a>) provides another option for implementing WS-Security. For the Signature and Encryption actions, you'll need to create a public &amp; private key for the entities involved. You can generate a self-signed key pair for your development environment via the following steps. Keep in mind these will not be signed by an external authority like Verisign, so are inappropriate for production use.</p><p>1. Creating private key with given alias and password like "myAlias"/"myAliasPassword" in keystore (protected by password for<br clear="none"> security reasons)</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">keytool -genkey -alias myAlias -keypass myAliasPassword -keystore \ 
  privatestore.jks -storepass keyStorePassword -dname "cn=myAlias" -keyalg RSA
</pre>
</div></div><p>The alias is simply a way to identify the key pair. In this instance we are using the RSA algorithm.</p><p>2. Self-sign our certificate (in production environment this will be done by a company like Verisign).</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">keytool -selfcert -alias myAlias -keystore privatestore.jks \ 
    -storepass keyStorePassword -keypass myAliasPassword
</pre>
</div></div><p>3. Export the public key from our private keystore to file named key.rsa</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">keytool -export -alias myAlias -file key.rsa -keystore privatestore.jks \ 
    -storepass keyStorePassword
</pre>
</div></div><p>4. Import the public key to new keystore:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">keytool -import -alias myAlias  -file key.rsa -keystore publicstore.jks \ 
    -storepass keyStorePassword
</pre>
</div></div><p>So now we have two keystores containing our keys - a public one (publicstore.jks) and a private one (privatestore.jks). Both of them have keystore password set to keyStorePass (this not recommended for production but ok for development) and alias set to myAlias. The file key.rsa can removed from filesystem, since it used only temporarily. Storing keys in keystores is strongly advised because a keystore is protected by a password.</p><p>A more detailed description of key generation can be found here:<br clear="none"> <a shape="rect" class="external-link" href="http://java.sun.com/javase/6/docs/technotes/tools/solaris/keytool.html" rel="nofollow">http://java.sun.com/javase/6/docs/technotes/tools/solaris/keytool.html</a></p><p>How to create a production certificate can be found here:<br clear="none"> <a shape="rect" class="external-link" href="http://support.globalsign.net/en/objectsign/java.cfm" rel="nofollow">http://support.globalsign.net/en/objectsign/java.cfm</a></p><h3 id="WSSecurity-Signing">Signing</h3><p>Signing a message is used to validate to the recipient that the message could only have come from a certain sender, and that the message was not altered in transit. It involves the sender encrypting a digest (hash) of the message with its private key, and the recipient decrypting the hash with the sender's public key, and recalculating the digest of the message to make sure the message was not altered in transit (i.e., that the digest values calculated by both the sender and recipient are the same). For this process to occur you must ensure that the Client's public key has been imported into the server's keystore using keytool.</p><p>On the client side, our outgoing WS-Security properties will look like so (see <a shape="rect" href="ws-security.html">above</a> for code sample):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">outProps.put(WSHandlerConstants.ACTION, "Signature");
outProps.put(WSHandlerConstants.USER, "myAlias");
outProps.put(WSHandlerConstants.PW_CALLBACK_CLASS, 
    ClientCallbackHandler.class.getName());
outProps.put(WSHandlerConstants.SIG_PROP_FILE, "client_sign.properties");
</pre>
</div></div><p>The USER that is specified is the key alias for the client. The password callback class is responsible for providing that key's password.</p><div class="confluence-information-macro confluence-information-macro-tip"><p class="title">Tip</p><span class="aui-icon aui-icon-small aui-iconfont-approve confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>For X.509 support you will normally have multiple actions, e.g. Encryption with Signature. For these cases, just space-separate the actions in the ACTION property as follows:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">outProps.put(WSHandlerConstants.ACTION, 
    WSHandlerConstants.TIMESTAMP + " " + 
    WSHandlerConstants.SIGNATURE + " " + 
    WSHandlerConstants.ENCRYPT);
</pre>
</div></div><p>Alternatively, you may space-separate the string literals you see above in the Spring configuration (e.g., "Signature Encrypt")</p></div></div><p>Our client_sign.properties file contains several settings to configure WSS4J:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=keyStorePassword
org.apache.ws.security.crypto.merlin.keystore.alias=myAlias
org.apache.ws.security.crypto.merlin.keystore.file=client_keystore.jks
</pre>
</div></div><p>On the server side, we need to configure our incoming WSS4J interceptor to verify the signature using the Client's public key.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">inProps.put(WSHandlerConstants.ACTION, "Signature");
inProps.put(WSHandlerConstants.SIG_PROP_FILE, "server.properties");
</pre>
</div></div><p>Our server_sign.properties file contains several settings to configure WSS4J:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=amex123
org.apache.ws.security.crypto.merlin.keystore.file=server_keystore.jks
</pre>
</div></div><h3 id="WSSecurity-Encryption">Encryption</h3><p>Encryption involves the sender encrypting the message with the recipient's public key to ensure that only the recipient can read the message (only the recipient has its own private key, necessary for decrypting the message.) This requires the sender to have the recipient's public key in its keystore.</p><p>The process for encrypting is very similar to and indeed usually combined with the signature process above. Our <a shape="rect" class="external-link" href="http://svn.apache.org/viewvc/cxf/trunk/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/security/">WS-Security test sample</a> (svn checkout <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/security/">http://svn.apache.org/repos/asf/cxf/trunk/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/security/</a>) provides an example of encrypting requests and responses, also check <a shape="rect" class="external-link" href="http://www.jroller.com/gmazza/entry/cxf_x509_profile" rel="nofollow">this blog entry</a> for a more end-to-end example showing signature and encryption of both SOAP requests and responses.</p><h1 id="WSSecurity-SecurityBestPractices">Security Best Practices</h1><p>Some guidelines are given at the WSS4J website about <a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/best_practice.html">best practices</a> when using WS-Security. It is recommended to study the guidelines carefully.</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </table>
   </td>
   <td id="cell-2-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
   <td id="cell-3-0">&nbsp;</td>
   <td id="cell-3-1">&nbsp;</td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">Privacy Policy</a> - 
         (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=49572">edit page</a>) 
	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=49572&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)<br>
	Apache CXF, CXF, Apache, the Apache feather logo are trademarks of The Apache Software Foundation.<br>
        All other marks mentioned may be trademarks or registered trademarks of their respective owners.
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3">&nbsp;</td>
   <td id="cell-3-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2">&nbsp;</td>
    <td id="cell-4-1">&nbsp;</td>
    <td id="cell-4-2" colspan="2">&nbsp;</td>
  </tr>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

