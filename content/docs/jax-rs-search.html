
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Search">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>
Apache CXF -- JAX-RS Search
    </title>
  </head>
<body onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td id="cell-0-0" colspan="2">&nbsp;</td>
    <td id="cell-0-1">&nbsp;</td>
    <td id="cell-0-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-1-0">&nbsp;</td>
    <td id="cell-1-1">&nbsp;</td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight: bold; font-size: 170%; color: white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="The Apache Sofware Foundation"><img border="0" alt="ASF Logo" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs -->
<a href="index.html">Index</a>&nbsp;&gt;&nbsp;<a href="restful-services.html">RESTful Services</a>&nbsp;&gt;&nbsp;<a href="jax-rs.html">JAX-RS</a>&nbsp;&gt;&nbsp;<a href="jax-rs-advanced-features.html">JAX-RS Advanced Features</a>&nbsp;&gt;&nbsp;<a href="jax-rs-search.html">JAX-RS Search</a>
                <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">Download</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">Documentation</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </table>
      </div>
    </td>
    <td id="cell-1-3">&nbsp;</td>
    <td id="cell-1-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2">&nbsp;</td>
    <td id="cell-2-1">
      <table>
        <tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">Overview</a></li><li><a shape="rect" href="how-tos.html">How-Tos</a></li><li><a shape="rect" href="frontends.html">Frontends</a></li><li><a shape="rect" href="databindings.html">DataBindings</a></li><li><a shape="rect" href="transports.html">Transports</a></li><li><a shape="rect" href="configuration.html">Configuration</a></li><li><a shape="rect" href="debugging-and-logging.html">Debugging and Logging</a></li><li><a shape="rect" href="tools.html">Tools</a></li><li><a shape="rect" href="restful-services.html">RESTful Services</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL Bindings</a></li><li><a shape="rect" href="service-routing.html">Service Routing</a></li><li><a shape="rect" href="dynamic-languages.html">Dynamic Languages</a></li><li><a shape="rect" href="ws-support.html">WS-* Support</a></li><li><a shape="rect" href="advanced-integration.html">Advanced Integration</a></li><li><a shape="rect" href="deployment.html">Deployment</a></li><li><a shape="rect" href="schemas-and-namespaces.html">Use of Schemas and Namespaces</a></li></ul><hr><ul class="alternate"><li><p>Search</p></li></ul><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF Website</a></li></ul><p>&#160;</p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="JAXRSSearch-JAX-RSSearch">JAX-RS Search</h1><p><br clear="none"></p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1636141627227 {padding: 0px;}
div.rbtoc1636141627227 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1636141627227 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1636141627227">
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-JAX-RSSearch">JAX-RS Search</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-AdvancedSearchQueries">Advanced Search Queries</a></li><li><a shape="rect" href="#JAXRSSearch-SupportedQueryLanguages">Supported Query Languages</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-FeedItemQueryLanguage">Feed Item Query Language</a></li><li><a shape="rect" href="#JAXRSSearch-OpenDataProtocol">Open Data Protocol</a></li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-Whentouseadvancedqueries.">When to use advanced queries.</a></li><li><a shape="rect" href="#JAXRSSearch-DependenciesandConfiguration">Dependencies and Configuration</a></li><li><a shape="rect" href="#JAXRSSearch-Workingwiththequeries">Working with the queries</a></li><li><a shape="rect" href="#JAXRSSearch-Capturingthequeries">Capturing the queries</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-Mappingofquerypropertiestobeanproperties">Mapping of query properties to bean properties</a></li><li><a shape="rect" href="#JAXRSSearch-Dealingwithmistypedpropertynames">Dealing with mistyped property names</a></li><li><a shape="rect" href="#JAXRSSearch-Parserproperties">Parser properties</a></li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-Mappingofquerypropertiestocolumn/fieldnames">Mapping of query properties to column/field names</a></li><li><a shape="rect" href="#JAXRSSearch-SearchBean">SearchBean</a></li><li><a shape="rect" href="#JAXRSSearch-Convertingthequeries">Converting the queries</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-SQL">SQL</a></li><li><a shape="rect" href="#JAXRSSearch-JPA2.0">JPA 2.0</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-Countexpressions">Count expressions</a></li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-Lucene">Lucene</a></li><li><a shape="rect" href="#JAXRSSearch-LDAP">LDAP</a></li><li><a shape="rect" href="#JAXRSSearch-Customvisitors">Custom visitors</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-Untypedconverters">Untyped converters</a></li><li><a shape="rect" href="#JAXRSSearch-Typedconverters">Typed converters</a></li><li><a shape="rect" href="#JAXRSSearch-Customparsing">Custom parsing</a></li></ul>
</li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-ConvertingthequerieswithQueryContext">Converting the queries with QueryContext</a></li><li><a shape="rect" href="#JAXRSSearch-PlainqueriestoFIQLconversion">Plain queries to FIQL conversion</a></li><li><a shape="rect" href="#JAXRSSearch-SearchExpressionsinURIPathsegments">Search Expressions in URI Path segments</a></li><li><a shape="rect" href="#JAXRSSearch-Queriesinvolvingmultipleentities">Queries involving multiple entities</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-Basicqueries">Basic queries</a></li><li><a shape="rect" href="#JAXRSSearch-Complexqueries">Complex queries</a></li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-Validation">Validation</a></li><li><a shape="rect" href="#JAXRSSearch-Buildingthequeries">Building the queries</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-FIQL">FIQL</a></li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-Usingdatesinqueries">Using dates in queries</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-Relativedates">Relative dates</a></li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-Alternativequerylanguages">Alternative query languages</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-OData">OData</a></li></ul>
</li><li><a shape="rect" href="#JAXRSSearch-ContentExtraction">Content Extraction</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSSearch-UsingTikaContentExtractor">Using&#160;TikaContentExtractor</a></li><li><a shape="rect" href="#JAXRSSearch-UsingTikaLuceneContentExtractor">Using&#160;TikaLuceneContentExtractor</a></li></ul>
</li></ul>
</li></ul>
</div><h2 id="JAXRSSearch-AdvancedSearchQueries">Advanced Search Queries</h2><p>CXF supports mapping the advanced query expressions to the typed Search API with the help of query language specific parsers.&#160; &#160;</p><h2 id="JAXRSSearch-SupportedQueryLanguages">Supported Query Languages</h2><h3 id="JAXRSSearch-FeedItemQueryLanguage">Feed Item Query Language</h3><p><a shape="rect" class="external-link" href="http://tools.ietf.org/html/draft-nottingham-atompub-fiql-00" rel="nofollow">Feed Item Query Language</a>(FIQL) is supported since CXF 2.3.0.</p><p>For example, the following query</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_s=name==CXF;version=ge=2.2
</pre>
</div></div><p>lets users search for all the Apache projects with the name 'CXF' and the version greater or equal to '2.2'. The initial '=' separates the name of the query '_s' from the FIQL expression, while '==' and '=ge=' convey 'equals to' and 'greater or equals to' respectively.<br clear="none">An expression such as "name==CXF*" can be used to do the partial equality check (example: the name should start from "CXF").</p><p>More complex composite expressions can also be expressed easily enough, examples:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Find all employees younger than 25 or older than 35 living in London
/employees?_s=(age=lt=25,age=gt=35);city==London

// Find all books on math or physics published in 1999 only.
/books?_s=date=lt=2000-01-01;date=gt=1999-01-01;(sub==math,sub==physics)

</pre>
</div></div><p>Here is a summary of FIQL operators:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Operator</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"=="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"!="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Not Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"=lt="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Less Than</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"=le="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Less or Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"=gt="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Greater Than</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"=ge="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Greater or Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>";"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>AND</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>","</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>OR</p></td></tr></tbody></table></div><p>The last two operators, ","(OR) and ";"(AND) are used to concatenate and build composite (possibly nested) expressions, while the first 6 operators are used to build so called primitive expressions.</p><p>From CXF 2.7.7: single '=' operator can be optionally supported instead of '==': set a "fiql.support.single.equals.operator" contextual property to "true".</p><p>As you can see FIQL is rich enough for the service implementations to offer a more interesting search experience around the well-known data, while still keeping the complexity of URI expressions under control which makes it simpler to share such URI queries as well as use the same query language no matter what data store is used internally by the service.</p><p>Note, when passing the FIQL queries via URI query parameters, either '_search' or '_s' query parameter has to be used to mark a FIQL expression for it not to 'interfere' with other optional query parameters. Starting from CXF 2.7.2 it is also possible to use the whole query component to convey a FIQL expression, example,</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Find all books on math or physics published in 1999 only.
/books?date=lt=2000-01-01;date=gt=1999-01-01;(sub==math,sub==physics)

</pre>
</div></div><p>Note that no "_s" or "_search" query parameter is available, the whole query string starting after "?" represents an actual FIQL expression.<br clear="none">Please use "search.use.all.query.component" contextual property for this option be supported.</p><p>Alternatively the expressions can be encoded as URI path segments, see the sections below for more information.</p><h3 id="JAXRSSearch-OpenDataProtocol">Open Data Protocol</h3><p>CXF 3.0.0-milestone2 supports the <a shape="rect" class="external-link" href="http://docs.oasis-open.org/odata/odata/v4.0/cos01/part2-url-conventions/odata-v4.0-cos01-part2-url-conventions.html#_Toc372793792" rel="nofollow">$filter</a> query defined as part of <a shape="rect" class="external-link" href="http://www.odata.org/" rel="nofollow">Open Data Protocol</a>, courtesy of <a shape="rect" class="external-link" href="http://olingo.incubator.apache.org/">Apache Olingo</a>.</p><p>The $filter query can have a number of the logical operators, here is a summary of the operators supported in scope of Search API:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Operator</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"eq"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"ne"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Not Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"lt"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Less Than</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"le"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Less or Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"gt"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Greater Than</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"ge"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Greater or Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"and"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>AND</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"or"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>OR</p></td></tr></tbody></table></div><p><br clear="none"></p><p>Please see the specification text for <a shape="rect" class="external-link" href="http://docs.oasis-open.org/odata/odata/v4.0/cos01/part2-url-conventions/odata-v4.0-cos01-part2-url-conventions.html#_Toc372793804" rel="nofollow">some examples</a>.</p><p>Please note that OData protocol is not supported by CXF Search API, only the $filter query is supported (only logical operators for now) for querying the application data with CXF Search API. Users should work directly with <a shape="rect" class="external-link" href="http://olingo.incubator.apache.org/">Apache Olingo</a> to get the <a shape="rect" class="external-link" href="http://www.odata.org/" rel="nofollow">OData</a> protocol supported as part of the application flow.</p><p>Some of the following examples on this page may often refer to FIQL due to the fact FIQL has been supported for a long time, but the same examples will work with OData $filter expressions. For example, replace the "_s=name==CXF" query with "$filter=name eq CXF".</p><h2 id="JAXRSSearch-Whentouseadvancedqueries.">When to use advanced queries.</h2><p>Consider a typical query expression such as "a=avalue&amp;c=cvalue". This can mean either "find all resources with 'a' and 'c' properties equal to 'avalue' and 'cvalue'" or "find all resources with 'a' or 'c' properties equal to 'avalue' and 'cvalue'". It is application specific on whether it is "and" or "or" as far as the combination of multiple query properties is concerned.</p><p>It is also to capture conditional expressions with the custom language, example, "find all resource with 'a' property less than 123" when a number of properties is large or the entities which can be searched are created dynamically.</p><p>Use FIQL or OData for capturing simple or medium complexity queries, typically in cases where a set of properties that a user can specify is well-known. Example, a book store resource will let users search books given a number of useful properties(those of Book and/or Library a given book is available in, etc).</p><p>Furthermore, consider using FIQL/OData and SearchConditionVisitor for the purpose of generalizing the search code, when the number of properties and entities is large, dynamic, etc.</p><h2 id="JAXRSSearch-DependenciesandConfiguration">Dependencies and Configuration</h2><p>The following dependency is required starting from CXF 2.6.0:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;cxf-rt-rs-extension-search&lt;/artifactId&gt;
    &lt;version&gt;2.6.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- If working with OData --&gt;
&lt;!--
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.olingo&lt;/groupId&gt;
    &lt;artifactId&gt;olingo-odata2-core-incubating&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt;/version&gt; 
&lt;/dependency&gt;
--&gt;
</pre>
</div></div><p>Additionally, starting from CXF 2.6.0, <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchContextProvider.java" rel="nofollow">SearchContextProvider</a> needs to be registered as jaxrs:provider.</p><h2 id="JAXRSSearch-Workingwiththequeries">Working with the queries</h2><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchContext.java" rel="nofollow">SearchContext</a> needs be injected into an application code and used to retrieve a <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchCondition.java" rel="nofollow">SearchCondition</a> representing the current FIQL/OData query. This SearchCondition can be used in a number of ways for finding the matching data.</p><p>In this section we assume that the data to be matched are already available in memory. The follow-up section on converting the queries will show how the queries can be converted to some other query language typed or text expression.</p><p>So, suppose a list or map of Book instances is available. Here is one possible approach:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("books")
public class Books {

    private Map&lt;Long, Book&gt; books;
    @Context
    private SearchContext context;

    @GET
    public List&lt;Book&gt; getBook() {

        SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
        // SearchCondition#isMet method can also be used to build a list of matching beans

        // iterate over all the values in the books map and return a collection of matching beans
        List&lt;Book&gt; found = sc.findAll(books.values());
        return found;
    }
}
</pre>
</div></div><p>Note that a searchContext.getCondition(Book. class) call may return an arbitrary complex SearchCondition, it can be a simple primitiveexpression or a more complex, composite one.</p><h2 id="JAXRSSearch-Capturingthequeries">Capturing the queries</h2><p>For the query expression to be captured, a bean like Book.class is instantiated and has all the search properties injected into it. A complex composite expression will be 'injected' into a number of Book instances - something that may have to be optimized.</p><p>Note that by default, a bean such as Book class needs to have a matching property per every property name found in the FIQL expression, for example, given a 'name==b;id==123' expression, the Book class would need to have 'name' and 'id' properties available. The reason for this strict mode being enabled by default is that ignoring a property which can not be captured may lead to a false or unexpected match, for example, if Book 'name' property has been renamed to 'title' then ignoring the 'name' property will lead to a wider match. Thus, if the property does not exist, org.apache.cxf.jaxrs.ext.search.PropertyNotFoundException will be thrown; capturing it can let returning an empty response or retry with the more lax mode, see the next paragraph.</p><p>When a more lax parsing of FIQL expressions is expected, for example, where the primitive expressions are joined by "OR", using SearchBean (see one of the next subsections) or setting a contextual property "search.lax.property.match" will help. The former option is better when you need to know the list of all the properties which have been used in the expression, even those which will not be possible to use for the actual search; the latter option will simply have the unrecognized properties ignored.</p><p>Note that a "search.decode.values" property can be used to have the 'reserved' characters such as FIQL ',' or ';' characters passed as percent-encoded characters as part of the search property values.</p><h3 id="JAXRSSearch-Mappingofquerypropertiestobeanproperties">Mapping of query properties to bean properties</h3><p>As noted above, when a 'typed' bean such as Book.class is used to capture the expressions, a property found in the query expression that can not be mapped to a specific Book property will lead to an exception being reported or it can be optionally ignored. In the reality, there is a number of reasons why the direct match between properties found in query expressions and in capturing beans may not be ideal:</p><ul class="alternate"><li>Capturing beans may evolve independently of the actual queries; for example, a working query such as "name==b" will break if a Book 'name' gets renamed to 'title' which will make it difficult to have the queries bookmarked.</li><li>Direct match will simply not work for cases where an actual bean property does not belong to the capturing bean itself but to one of its child properties; for example, a JPA2 Book entity may have an OwnerInfo bean with Name bean property which does contain a primitive 'name' property.</li></ul><p>The preferred approach, when working with typed beans, is to register a bean properties map, using a "search.bean.property.map" contextual property or directly with SearchContext. For example, given</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Book {

    private int id;
    private OwnerInfo ownerinfo;
    //setters and getters omitted for brevity
}

@Embeddable
public class OwnerInfo {

    private Address address;
    private Name name;
    //setters and getters omitted for brevity
}

@Embeddable
public class Name {

    private String name;
    //setters and getters omitted for brevity
}
</pre>
</div></div><p>and the following map:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;map&gt;
 &lt;!-- 'oname' is alias for the actual nested bean property --&gt;
 &lt;entry key="oname" value="ownerinfo.name.name"/&gt;
&lt;/map&gt;
</pre>
</div></div><p>will let users type and bookmark queries (and without seeing them producing unexpected results) like this one:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">//Find all the books owned by Fred with id greater than 100
/books?_s=id=gt=100;oname=Fred
</pre>
</div></div><p>Note, a property name such as "ownerinfo.name.name" uses '.' to let the parser navigate to the actual Name bean which has a 'name' property. This can be optimized in cases where the owner bean is known to have either a constructor or static valueOf() method accepting the 'name' property, for example, given</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Name {

    private String name;
    public Name() {
    } 
    public Name(String name) {
        this.name = name;
    }
    //setters and getters omitted for brevity
}
</pre>
</div></div><p>the mapping between "oname" and "ownerinfo.name" will work too.</p><p>You can also have many to one mappings, for example</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;map&gt;
 &lt;!-- 'oname' and 'owner' are aliases for the 'ownerinfo.name.name' bean property --&gt;
 &lt;entry key="oname" value="ownerinfo.name.name"/&gt;
 &lt;entry key="owner" value="ownerinfo.name.name"/&gt;
&lt;/map&gt;
</pre>
</div></div><h3 id="JAXRSSearch-Dealingwithmistypedpropertynames">Dealing with mistyped property names</h3><p>Consider a case where a documented search property is named as 'address' (lower case) and a query contains a mistyped 'Address' instead. In this case, unless a&#160;"search.lax.property.match" property is set, PropertyNotFoundException will be thrown.</p><p>Supporting case-insensitive property mapping is easy, register a "search.bean.property.map" (mentioned earlier) map as Java TreeMap</p><p>with a case-insensitive String.CASE_INSENSITIVE_ORDER Comparator.</p><p>However it will not help if the 'address' property was mistyped as 'adress'. In this case, "search.bean.property.map" might still be useful with having few more keys supporting some typical typos, example, 'adress' - 'address',&#160;'addres' - 'address', etc.</p><p>Starting from&#160; CXF 3.1.5,&#160;org.apache.cxf.jaxrs.ext.search.PropertyNameConverter&#160; is available and might be used for a more sophisticated conversion of mistyped property names to correct names.&#160;</p><p>The implementation can be registered as a "search.bean.property.converter" endpoint contextual property.</p><h3 id="JAXRSSearch-Parserproperties">Parser properties</h3><p>The parser properties are the ones which tell the parser how to treat the conversion of Date values and the unrecognized search property names.</p><p>As explained above, "search.lax.property.match" can be used to tell the parser that it should ignore the search property names which have no corresponding bean properties.</p><p>"search.date.format" and "search.timezone.support" tell the parser how to convert the date values, see "Using dates in queries" section.</p><p>More properties may be supported in the future.</p><p>All of these properties can be set as endpoint contextual properties or directly with SearchContext.</p><h2 id="JAXRSSearch-Mappingofquerypropertiestocolumn/fieldnames">Mapping of query properties to column/field names</h2><p>When converting FIQL queries to SQL or other untyped query language expressions, as well as when using Lucene converter, it can be useful to be able to map between an actual query parameter and the column or field name. All FIQL converters shipped with CXF have constructors accepting a map for mapping the queries to columns/fields. See the next "SearchBean" section for one example.</p><p>Note this property is not the same as the one described in the "Mapping of query properties to bean properties" section. The latter (the one described in the previous section) is required for getting FIQL queries captured into typed, domain specific beans like Book, and it can be sufficient for JPA2 which also has annotations like @Column.</p><h2 id="JAXRSSearch-SearchBean">SearchBean</h2><p>org.apache.cxf.jaxrs.ext.search.SearchBean is a utility bean class which can simplify analyzing the captured FIQL expressions and converting them to the other language expressions, in cases where having to update the bean class such as Book.class with all the properties that may need to be supported is not practical or the properties need to be managed manually. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// ?_s="level=gt=10"
SearchCondition&lt;SearchBean&gt; sc = searchContext.getCondition(SearchBean.class);

Map\&lt;, String\&gt; fieldMap = new HashMap\&lt;String, String\&gt;();
fieldMap.put("level", "LEVEL_COLUMN");

SQLPrinterVisitor&lt;SearchBean&gt; visitor = new SQLPrinterVisitor&lt;SearchBean&gt;(fieldMap, "table", "LEVEL_COLUMN");
sc.accept(visitor);
assertEquals("SELECT LEVEL_COLUMN FROM table 
              WHERE LEVEL_COLUMN &gt; '10'",
              visitor.getQuery());
</pre>
</div></div><h2 id="JAXRSSearch-Convertingthequeries">Converting the queries</h2><p>SearchCondition can also be used to convert the search requirements (originally expressed in FIQL/OData) into other query languages. <br clear="none">A custom <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchConditionVisitor.java" rel="nofollow">SearchConditionVisitor</a> implementation can be used to convert SearchCondition objects into custom expressions or typed objects. CXF ships visitors for converting expressions to SQL, JPA 2.0 CriteriaQuery or TypedQuery, Lucene Query.</p><h3 id="JAXRSSearch-SQL">SQL</h3><p>org.apache.cxf.jaxrs.ext.search.sql.SQLPrinterVisitor can be used for creating SQL expressions. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// ?_s="name==ami*;level=gt=10"
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
SQLPrinterVisitor&lt;Book&gt; visitor = new SQLPrinterVisitor&lt;Book&gt;("table");
sc.accept(visitor);
assertEquals("SELECT * FROM table 
              WHERE 
              name LIKE 'ami%' 
              AND 
              level &gt; '10'",
              visitor.getQuery());
</pre>
</div></div><p>Note that SQLPrinterVisitor can also be initialized with the names of columns and the field aliases map:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// ?_s="level=gt=10"
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);

Map&lt;String, String&gt; fieldMap = new HashMap&lt;String, String&gt;();
fieldMap.put("level", "LEVEL_COLUMN");

SQLPrinterVisitor&lt;Book&gt; visitor = new SQLPrinterVisitor&lt;Book&gt;(fieldMap, "table", "LEVEL_COLUMN");
sc.accept(visitor);
assertEquals("SELECT LEVEL_COLUMN FROM table 
              WHERE LEVEL_COLUMN &gt; '10'",
              visitor.getQuery());
</pre>
</div></div><p>The fields map can help hide the names of the actual table columns/record fields from the Web frontend. Example, the users will know that the 'level' property is available while internally it will be converted to a LEVEL_COLUMN name.</p><p><strong>Warning</strong>: Using the SQLPrinterVisitor may leave your service open to SQL injection attacks. Please take appropriate steps to avoid these attacks (for example validating queries using a custom PropertyValidator, or <a shape="rect" class="external-link" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User-Supplied_Input" rel="nofollow">manually escaping</a> the input values).</p><h3 id="JAXRSSearch-JPA2.0">JPA 2.0</h3><p>CXF 2.6.4 and CXF 2.7.1 introduce org.apache.cxf.jaxrs.ext.search.jpa.JPATypedQueryVisitor and org.apache.cxf.jaxrs.ext.search.jpa.JPACriteriaQueryVisitor which can be used to capture FIQL/OData expressions into <br clear="none">javax.persistence.TypedQuery or javax.persistence.criteria.CriteriaQuery objects.</p><p>For example, given:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Book {

    private String title;
    private Date date;
    private OwnerInfo ownerinfo;
    //setters and getters omitted for brevity
}

@Embeddable
public class OwnerInfo {

    private Address address;
    private Name name;
    //setters and getters omitted for brevity
}

@Embeddable
public class Name {

    private String name;
    //setters and getters omitted for brevity
}

@Embeddable
public class Address {

    private String street;
    //setters and getters omitted for brevity
}
</pre>
</div></div><p>the following code can be used:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;

// init EntityManager as required
private EntityManager entityManager;

// Find the books owned by Barry who lives in London, published starting from the first month of 2000 
// ?_s="date=ge=2000-01-01;ownername=barry;address=london"

// this map will have to be set as a contextual property on the jaxrs endpoint
// it assumes that Book bean has nested OwnerInfo bean with nested Address and Name beans, 
// with the latter containing 'street' and 'name' property respectively

Map&lt;String, String&gt; beanPropertiesMap = new HashMap&lt;String, String&gt;();
beanPropertiesMap.put("address", "ownerInfo.address.street");
beanPropertiesMap.put("ownername", "ownerInfo.name.name");

// the actual application code
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
SearchConditionVisitor&lt;Book, TypedQuery&lt;Book&gt;&gt; visitor = 
    new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
sc.accept(visitor);

TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
List&lt;Book&gt; books = typedQuery.getResultList();
</pre>
</div></div><p>Using CriteriaQuery is preferred in cases when the actual result has to be shaped into a bean of different type, using one of JPA2 CriteriaBuilder's shape methods (array(), construct() or tuple()). For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Find the books owned by Barry who lives in London, published starting from the first month of 2000 
// ?_s="date=ge=2000-01-01;ownername=barry;address=london"

// this map will have to be set as a contextual property on the jaxrs endpoint
Map&lt;String, String&gt; beanPropertiesMap = new HashMap&lt;String, String&gt;();
beanPropertiesMap.put("address", "ownerInfo.address.street");
beanPropertiesMap.put("ownername", "ownerInfo.name.name");

// the actual application code
// Only Book 'id' and 'title' properties are extracted from the list of found books
 
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
JPACriteriaQueryVisitor&lt;Book, Tuple&gt; visitor = 
    new JPACriteriaQueryVisitor&lt;Book, Tuple&gt;(entityManager, Book.class, Tuple.class);
sc.accept(visitor);

List&lt;SingularAttribute&lt;Book, ?&gt;&gt; selections = new LinkedList&lt;SingularAttribute&lt;Book, ?&gt;&gt;();
// Book_ class is generated by JPA2 compiler
selections.add(Book_.id);
selections.add(Book_.title);

visitor.selectTuple(selections);

TypedQuery&lt;Tuple&gt; query = visitor.getQuery();

List&lt;Tuple&gt; tuples = typedQuery.getResultList();
for (Tuple tuple : tuples) {
  int bookId = tuple.get("id", String.class);
  String title = tuple.get("title", String.class);
  // add bookId &amp; title to the response data
}

</pre>
</div></div><p>Note that JPACriteriaQueryVisitor will automatically set aliases for an expression like "tuple.get('id', String.class)" to work.<br clear="none">JPACriteriaQueryVisitor will be enhanced to support more of JPA2 advanced constructs in time.</p><p>Or, instead of using Tuple, use a capturing bean like BeanInfo:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public static class BookInfo {
    private int id;
    private String title;

    public BookInfo() {
            
    }
        
    public BookInfo(Integer id, String title) {
        this.id = id;
        this.title = title;
    }
    //setters and getters omitted for brevity
 }

// actual application code:

SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
JPACriteriaQueryVisitor&lt;Book, BookInfo&gt; visitor = 
    new JPACriteriaQueryVisitor&lt;Book, BookInfo&gt;(entityManager, Book.class, BookInfo.class);
sc.accept(visitor);

List&lt;SingularAttribute&lt;Book, ?&gt;&gt; selections = new LinkedList&lt;SingularAttribute&lt;Book, ?&gt;&gt;();
// Book_ class is generated by JPA2 compiler
selections.add(Book_.id);
selections.add(Book_.title);

visitor.selectConstruct(selections);

TypedQuery&lt;BookInfo&gt; query = visitor.getQuery();

List&lt;BookInfo&gt; bookInfo = typedQuery.getResultList();
return bookInfo;
</pre>
</div></div><p>JPA2 typed converters also support join operations in cases when explicit collections are used, for example, given:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Entity(name = "Book")
public class Book {

    private List&lt;BookReview&gt; reviews = new LinkedList&lt;BookReview&gt;();
    private List&lt;String&gt; authors = new LinkedList&lt;String&gt;();
    // other properties omitted

    @OneToMany
    public List&lt;BookReview&gt; getReviews() {
        return reviews;
    }

    public void setReviews(List&lt;BookReview&gt; reviews) {
        this.reviews = reviews;
    }

    @ElementCollection
    public List&lt;String&gt; getAuthors() {
        return authors;
    }

    public void setAuthors(List&lt;String&gt; authors) {
        this.authors = authors;
    }
}

@Entity
public class BookReview {
    private Review review;
    private List&lt;String&gt; authors = new LinkedList&lt;String&gt;();
    private Book book;
    // other properties omitted    

    public Review getReview() {
        return review;
    }

    public void setReview(Review review) {
        this.review = review;
    }

    @OneToOne
    public Book getBook() {
        return book;
    }

    public void setBook(Book book) {
        this.book = book;
    }

    @ElementCollection
    public List&lt;String&gt; getAuthors() {
        return authors;
    }

    public void setAuthors(List&lt;String&gt; authors) {
        this.authors = authors;
    }

    public static enum Review {
        GOOD,
        BAD
    }
}
</pre>
</div></div><p>the following will find "all the books with good reviews written by Ted":</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchCondition&lt;Book&gt; filter = new FiqlParser&lt;Book&gt;(Book.class).parse("reviews.review==good;reviews.authors==Ted");
// in practice, map "reviews.review" to "review", "reviews.authors" to "reviewAuthor" 
// and have a simple query like "review==good;reviewAuthor==Ted" instead

SearchConditionVisitor&lt;Book, TypedQuery&lt;Book&gt;&gt; jpa = new JPATypedQueryVisitor&lt;Book&gt;(em, Book.class);
filter.accept(jpa);
TypedQuery&lt;Book&gt; query = jpa.getQuery();
return query.getResultList();
</pre>
</div></div><p>org.apache.cxf.jaxrs.ext.search.jpa.JPALanguageVisitor for converting FIQL/OData expressions into JPQL expressions have also been introduced.</p><h4 id="JAXRSSearch-Countexpressions">Count expressions</h4><p>Count expressions are supported at the two levels,</p><p>First, one may want to get the count of records matching a given search expression, this actually can be done by checking the size of the result list:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">TypedQuery&lt;Book&gt; query = jpa.getQuery();
return query.getResultList().size();
</pre>
</div></div><p>However this can be very inefficient for large number of records, so using a CriteriaBuilder count operation is recommended, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchCondition&lt;Book&gt; filter = new FiqlParser&lt;Book&gt;(Book.class).parse("reviews.review==good;reviews.authors==Ted");

JPACriteriaQueryVisitor&lt;Book, Long&gt; jpa = new JPACriteriaQueryVisitor&lt;Book, Long&gt;(em, Book.class, Long.class);
filter.accept(jpa);
long count = jpa.count();
</pre>
</div></div><p><br clear="none"></p><p>Second, <strong>only when using FIQL</strong>, a count extension can be used. For example, one may want to find 'all the books written by at least two authors or all the books with no reviews'.<br clear="none">If a collection entity such as BookReview has a non primitive type, then typing "reviews==0" is all what is needed, otherwise a count extension needs to be used, for example: "count(authors)=ge=2"</p><h3 id="JAXRSSearch-Lucene">Lucene</h3><p>Mapping of FIQL/OData expressions to Lucene (4.0.0-BETA) Query is supported starting from CXF 2.7.1. Please notice that starting from CXF 3.0.2, the Lucene version has been upgraded to 4.9.0 in order to benefit from query builders and other improvements.</p><p>org.apache.cxf.jaxrs.ext.search.lucene.LuceneQueryVisitor can be used to support the default (content) field or specific custom field queries.<br clear="none">Queries for specific terms and phrases are supported.</p><p>Example, "find the documents containing a 'text' term":</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.lucene.search.Query;

SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("ct==text");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("ct", "contents");
lucene.visit(filter);
org.apache.lucene.search.Query termQuery = lucene.getQuery();
// use Query
</pre>
</div></div><p>Note, "new LuceneQueryVisitor&lt;SearchBean&gt;("ct", "contents");" is a simple constructor which lets create a mapping between the "ct" name used in the query and the actual default content field. It is not required to use this mapping but it is recommended as it keeps the query expression shorter and does not leak the actual internal Lucene field name.</p><p>All the FIQL operators have been mapped to related Lucene Query objects. Queries such as "Less than", or "Greater than and less than" will work fine against the typed fields like "org.apache.lucene.document.IntField". The visitor can be configured with a "primitiveFieldTypeMap" map property to help it map a given query name, example "id" to Integer.class.</p><p>Phrases are supported too. Suppose you have few documents with each of them containing name and value pairs like "name=Fred", "name=Barry" and you'd like to list only the documents containing "name=Fred":</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("name==Fred");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("contents");
lucene.visit(filter);
org.apache.lucene.search.Query phraseQuery = lucene.getQuery();
// use query
</pre>
</div></div><p>In this example, the visitor is requested to create Lucene org.apache.lucene.search.PhraseQuery against the specified contents field ("contents"). The visitor can also accept a contentsFieldMap map property when different phrases may need to be checked against different contents fields.</p><p>Starting from CXF 3.0.2, the typed Date range queries are supported by LuceneQueryVisitor. However, this feature should be used together with 'primitiveFieldTypeMap' in order to hint the visitor which fields are temporal and should be treated as such in the filter expressions. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Map&lt; String, Class&lt; ? &gt; &gt; fieldTypes = new LinkedHashMap&lt; String, Class&lt; ? &gt; &gt;();
fieldTypes.put( "modified", Date.class);

SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("modified=gt=2007-09-16");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("ct", "contents");
lucene.setPrimitiveFieldTypeMap(fieldTypes);
lucene.visit(filter);

org.apache.lucene.search.Query query = lucene.getQuery();</pre>
</div></div><p>LuceneQueryVisitor supports wide range of date formats, still providing the option to customize it using 'search.date-format' property. This property accepts the date/time pattern expression in the SimpleDateFormat format. Also, since CXF 3.0.2, the LuceneQueryVisitor&#160; could be configured to use the Lucene analyzer. The reason to use analyzer is that during Lucene query construction the visitor can use the per-field filters and tokenizers, taking into account stemming, stop-worlds, lower-casing, etc., as such properly processing the filter expression. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_4_9);

// Lower-case filter and stop-words filter are part of the StandardAnalyzer
SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("contents==pears and APPLES");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("contents", analyzer);
lucene.visit(filter);

org.apache.lucene.search.Query query = lucene.getQuery();</pre>
</div></div><p><br clear="none"></p><h3 id="JAXRSSearch-LDAP">LDAP</h3><p>Mapping of FIQL/OData expressions to LDAP queries as defined by <a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc4515" rel="nofollow">RFC-4515</a> is supported starting from CXF 2.7.1 with the help of org.apache.cxf.jaxrs.ext.search.ldap.LdapQueryVisitor. Use this visitor when working with LDAP or OSGI.</p><p>Here is a summary of LDAP filter operators:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Operator</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"!"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Not Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"&lt;="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Less Or Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"&gt;="</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Greater or Equal</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"&amp;"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>AND</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"|"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>OR</p></td></tr></tbody></table></div><p>FIQL "=le=" and "=lt=" will both map to "&lt;=", while "=ge=" and "=gt=" to "&gt;=".</p><p>For example:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>FIQL</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>LDAP</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"name==bar*"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>"(name=bar*)"</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"name!=bar"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>"(!name=bar)"</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"name!=bar;id=gt=10"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>"(&amp;(!name=bar)(id&gt;=10))"</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>"name!=bar;(id=gt=10,id=lt=5)"</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>"(&amp;(!name=bar)(|(id&gt;=10)(id&lt;=5)))"</p></td></tr></tbody></table></div><p>The converter is created like all other converters:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// FIQL "oclass=Bar"

// map 'oclass' used in the FIQL query to the actual property name, 'objectClass'
LdapQueryVisitor&lt;Condition&gt; visitor = 
   new LdapQueryVisitor&lt;Condition&gt;(Collections.singletonMap("oclass", "objectClass"));

filter.accept(visitor.visitor());
String ldap = visitor.getQuery();
</pre>
</div></div><p>Note that <a shape="rect" class="external-link" href="https://issues.apache.org/jira/browse/CXF-7701">since</a> CXF 3.2.5 the query values are encoded by default, to prevent possible LDAP injection attacks. If you want to support wildcard searching with the LdapQueryVisitor from CXF 3.2.5 onwards, it is necessary to set the 'encodeQueryValues' property of LdapQueryVisitor to 'false'.</p><h3 id="JAXRSSearch-Customvisitors">Custom visitors</h3><p>In cases when a custom conversion has to be done, a converter for doing the untyped (example, SQL) or typed (example, JPA2 TypedQuery) conversions can be provided.</p><h4 id="JAXRSSearch-Untypedconverters">Untyped converters</h4><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class CustomSQLVisitor&lt;T&gt; extends AbstractSearchConditionVisitor&lt;T, String&gt; {

    private String tableName;
    private StringBuilder sb = new StringBuilder();

    public void visit(SearchCondition&lt;T&gt; sc) {
        
        if (sb == null) {
            sb = new StringBuilder();
            // start the expression as needed, example
            // sb.append("Select from ").append(tableName);
        }
        
        PrimitiveStatement statement = sc.getStatement();
        if (statement != null) {
                // ex "a &gt; b"
                // use statement.getValue()
                // use statement.getConditionType() such as greaterThan, lessThan
                // use statement.getProperty();
                // to convert "a &gt; b" into SQL expression
                sb.append(toSQL(statement));         
        } else {
            // composite expression, ex "a &gt; b;c &lt; d"
            for (SearchCondition&lt;T&gt; condition : sc.getSearchConditions()) {
                // pre-process, example sb.append("(");
                condition.accept(this);
                // post-process, example sb.append(")");
            }
        }
    }

    public String getQuery() {
        return sb.toString();
    }
}
</pre>
</div></div><h4 id="JAXRSSearch-Typedconverters">Typed converters</h4><p>import org.custom.search.Query;</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class CustomTypedVisitor&lt;T&gt; extends AbstractSearchConditionVisitor&lt;T, Query&gt; {

    private Stack&lt;List&lt;Query&gt;&gt; queryStack = new Stack&lt;List&lt;Query&gt;&gt;();

    public void visit(SearchCondition&lt;T&gt; sc) {
                
        PrimitiveStatement statement = sc.getStatement();
        if (statement != null) {
                // ex "a &gt; b"
                // use statement.getValue()
                // use statement.getConditionType() such as greaterThan, lessThan
                // use statement.getProperty();
                // to convert "a &gt; b" into Query object
                Query query = buildSimpleQuery(statement);
                queryStack.peek().add(query);                 

        } else {
            // composite expression, ex "a &gt; b;c &lt; d"
            queryStack.push(new ArrayList&lt;Query&gt;());

            for (SearchCondition&lt;T&gt; condition : sc.getSearchConditions()) {
                condition.accept(this);
            }

            boolean orCondition = sc.getConditionType() == ConditionType.OR;
            List&lt;Query&gt; queries = queryStack.pop();
            queryStack.peek().add(createCompositeQuery(queries, orCondition));
        }
    }

    public Query getQuery() {
        return queryStack.peek().get(0);
    }
}
</pre>
</div></div><h4 id="JAXRSSearch-Customparsing">Custom parsing</h4><p>If needed you can access a FIQL/OData query directly and delegate it further to your own custom FIQL handler:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/search")
public class SearchEngine {
    @Context
    private UriInfo ui;

    @GET
    public List&lt;Book&gt; findBooks() {
        MultivaluedMap&lt;String, String&gt; params = ui.getQueryParameters();
        String query = params.getFirst("_s"); // or $filter, etc
        // delegate to your own custom handler 

        // note that the original search expression can also be retrieved 
        // using a SearchContext.getSearchExpression() method
}
</pre>
</div></div><h2 id="JAXRSSearch-ConvertingthequerieswithQueryContext">Converting the queries with QueryContext</h2><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/QueryContext.javahe/cxf/jaxrs/ext/search/QueryContext.java" rel="nofollow">QueryContext</a> is the helper context available from CXF 2.7.1 which makes it simpler for the application code to<br clear="none">get the converted query expression, with the actual converter/visitor registered as the jaxrs contextual property, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.util.ArrayList;
import java.util.List;
import org.apache.cxf.jaxrs.JAXRSServerFactoryBean;
import org.apache.cxf.jaxrs.ext.search.QueryContextProvider;
import org.apache.cxf.jaxrs.ext.search.SearchBean;
import org.apache.cxf.jaxrs.ext.search.visitor.SBThrealLocalVisitorState;
import org.apache.cxf.jaxrs.ext.search.sql.SQLPrinterVisitor;

import books.BookStore;

// Register the visitor:
JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();
List&lt;Object&gt; providers = new ArrayList&lt;Object&gt;();
providers.add(new QueryContextProvider());
sf.setProviders(providers);

SQLPrinterVisitor&lt;SearchBean&gt; sqlVisitor = new SQLPrinterVisitor&lt;SearchBean&gt;("books");
sqlVisitor.setVisitorState(new SBThrealLocalVisitorState());
sf.getProperties(true).put("search.visitor", sqlVisitor);

sf.setResourceClasses(BookStore.class);
server = sf.create();
</pre>
</div></div><p>and convert the queries:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/")
public class BookStore { 
    @GET
    @Path("/books/{expression}")
    @Produces("application/xml")
    public List&lt;Book&gt; getBookQueryContext(@PathParam("expression") String expression, 
                                      @Context QueryContext searchContext) 
        throws BookNotFoundFault {
        String sqlExpression = searchContext.getConvertedExpression(expression, Book.class);
        // pass it to the SQL DB and return the list of Books
    }
}
</pre>
</div></div><p>where the client code may look like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">String address = "http://localhost:8080/bookstore/books/id=ge=123";
WebClient client = WebClient.create(address);
client.accept("application/xml");
List&lt;Book&gt; books = client.getCollection(Book.class);
</pre>
</div></div><p>Note, given that SQLPrinterVisitor will be shared between multiple requests it has to be made thread-safe by injecting a thread-local<br clear="none">org.apache.cxf.jaxrs.ext.search.visitor.SBThrealLocalVisitorState. This is not required when the visitor is created in the code on the per-request basis.</p><p>Custom visitors which are expected to be singletons and have the state accumulating between multiple visit calls have to be thread safe. Utility org.apache.cxf.jaxrs.ext.search.visitor.ThrealLocalVisitorState class can be used.</p><h2 id="JAXRSSearch-PlainqueriestoFIQLconversion">Plain queries to FIQL conversion</h2><p>If you'd like to generalize the processing of search queries and use FIQL visitors, you may want to consider setting up a contextual property "search.use.plain.queries" to "true" and get the plain query expressions converted to FIQL expressions internally.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// GET /search?a=a1&amp;a=v2
String exp = searchContext.getSearchExpression();
assertEquals("(a==a1,a==a2)", exp);

// GET /search?a=a1&amp;b=b1
exp = searchContext.getSearchExpression();
assertEquals("(a==a1;b==b1)", exp);
</pre>
</div></div><p>Also, by default, if a query property name ends with "From" then "=ge=" (greater or equals to) will be used, and if ends with "Till" then "=lt=" will be used, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// GET /search?ageFrom=10&amp;ageTill=20
String exp = searchContext.getSearchExpression();
assertEquals("(age=ge=10,age=le=20)", exp);
</pre>
</div></div><p>This can allow the plain query expressions mapped to typed bean properties and further used with all the existing converters.</p><h2 id="JAXRSSearch-SearchExpressionsinURIPathsegments">Search Expressions in URI Path segments</h2><p>By default, a FIQL expression is expected to be available in either '_s' or '_search' query.<br clear="none">For example, "find all the books with an 'id' property value less than 123":</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">GET /books?_s=id=lt=123
</pre>
</div></div><p>Starting from CXF 2.6.2, it is possible to work with FIQL expressions included in URI path segments, for example, the same query can be expressed<br clear="none">in a number of ways:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">GET /books/id=lt=123
GET /books[id=lt=123]
GET /books(id=lt=123)
GET /books;id=lt=123

//etc, etc

</pre>
</div></div><p>Such expressions can be captured in the code using JAX-RS annotations:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /books[id=lt=123]
   @GET
   @Path("books[{search}]") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   //GET /books(id=lt=123)
   @GET
   @Path("books({search})") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   //GET /books/id=lt=123
   @GET
   @Path("books/{search}") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   //GET /books;id=lt=123
   @GET
   @Path("books;{search}") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   public List&lt;Book&gt; doFindSelectedBooks(String searchExpression) {
       SearchCondition&lt;Book&gt; sc = context.getCondition(searchExpression, Book.class);
   
       // JPA2 enity manager is initialized earlier
       JPATypedQuery&lt;Book&gt; visitor = new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
       sc.accept(visitor);
   
       TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
       return typedQuery.getResultList();
   }

}
</pre>
</div></div><p>Note that if you have an expression added to a URI path segment with a ";" character acting as a separator, example, "/books;id=lt=123",<br clear="none">or if an expression itself includes ";", example, "/books[id=lt=123;id=gt=300]" ("find all the books with id less than 123 or greater than 300") <br clear="none">then a boolean contextual property "ignore.matrix.parameters" has to be set to "true" for the runtime to avoid splitting the path segment into the path value and matrix parameters.</p><h2 id="JAXRSSearch-Queriesinvolvingmultipleentities">Queries involving multiple entities</h2><h3 id="JAXRSSearch-Basicqueries">Basic queries</h3><p>Consider the query like "find chapters with a given chapter id from all the books with 'id' less than 123".<br clear="none">One easy way to manage such queries is to make FIQL and JAX-RS work together. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /books[id=lt=123]/chapter/1
   @GET
   @Path("books[{search}]/chapter/{id}") 
   public List&lt;Chapter&gt; findSelectedChapters(@PathParam("search") String searchExpression,
                                       @PathParam("id") int chapterIndex) {
       return doFindSelectedChapters(searchExpression, chapterIndex);
   }

   public List&lt;Chapter&gt; doFindSelectedChapters(String searchExpression, int chapterIndex) {
       SearchCondition&lt;Book&gt; sc = context.getCondition(searchExpression, Book.class);
   
       // JPA2 enity manager is initialized earlier
       JPATypedQuery&lt;Book&gt; visitor = new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
       sc.accept(visitor);
   
       TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
       List&lt;Book&gt; books = typedQuery.getResultList();

       List&lt;Chapter&gt; chapters = new ArrayList&lt;Chapter&gt;(books.size);
       for (Book book : books) {
           chapters.add(book.getChapter(chapterIndex)); 
       }   
       return chapters;
   }

}
</pre>
</div></div><h3 id="JAXRSSearch-Complexqueries">Complex queries</h3><p>In the previous section we had the properties of two entities, Book and Chapter, used in the query. The query was considered 'simple' because it was really only the simple book properties that were checked, and the only chapter property was a chapter id, assumed to be equal to a chapter list index.</p><p>Consider "Find all the chapters with id less than 5 for all the books with id greater than 300".</p><p>One way to handle is to follow the example from the previous section with few modifications:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /books(id=gt=300)/chapters(id=lt=5)
   @GET
   @Path("books({search1})/chapter/{search2}") 
   public List&lt;Chapter&gt; findSelectedChapters(@PathParam("search1") String bookExpression,
                                       @PathParam("search2") String chapterExpression) {
       return doFindSelectedBooks(bookExpression, chapterExpression);
   }

   public List&lt;Chapter&gt; doFindSelectedChapters(String bookExpression, String chapterExpression) {
       // find the books first
       
       SearchCondition&lt;Book&gt; bookCondition = context.getCondition(searchExpression, Book.class);
   
       JPATypedQuery&lt;Book&gt; visitor = new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
       bookCondition.visit(visitor);
       TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
       List&lt;Book&gt; books = typedQuery.getResultList();

       // now get the chapters
       SearchCondition&lt;Chapter&gt; chapterCondition = context.getCondition(chapterExpression, Chapter.class);
       List&lt;Chapter&gt; chapters = new ArrayList&lt;Chapter&gt;();
       for (Book book : books) {
           chapters.addAll(chapterCondition.findAll(book.getChapters()); 
       }   
       return chapters;
   }

}
</pre>
</div></div><p>In this case two conditions are created and the 2nd condition is used to filter the chapters from the books filtered by the 1st condition.</p><p>Perhaps a simpler approach, especially in case of JPA2, is to start looking for Chapters immediately, assuming Chapter classes have a one to one bidirectional relationship with Book:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Chapter {
   private int id;
   private Book book;

   @OneToOne(mappedBy="book")
   public Book getBook() {}
}

@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /chapters(bookId=gt=300,id=lt=5)
   @GET
   @Path("chapters({search})") 
   public List&lt;Chapter&gt; findSelectedChapters(@PathParam("search") String chapterExpression) {
       
       SearchCondition&lt;Chapter&gt; chapterCondition = context.getCondition(chapterExpression, Chapter.class);
   
       JPATypedQuery&lt;Chapter&gt; visitor = new JPATypedQueryVisitor&lt;Chapter&gt;(entityManager, Chapter.class);
       chapterCondition.visit(visitor);
       TypedQuery&lt;Chapter&gt; typedQuery = visitor.getQuery();
       return typedQuery.getResultList();
   }

}
</pre>
</div></div><p>Note this code assumes that "bookId" is mapped to "Book.id" property with the help of the contextual "search.bean.property.map" property as explained earlier.</p><h2 id="JAXRSSearch-Validation">Validation</h2><p>First option is to have a bean capturing specific property values do a domain specific validation. For example, a Book.class may have its setName(String name) method validating the name value. <br clear="none">Another option is to inject a custom <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/visitor/PropertyValidator.java" rel="nofollow">validator</a> into a visitor which is used to build the untyped or typed query.</p><p>Finally, avoid letting users to use properties whose values which can not be well validated in the application code. Using a typed capturing bean like Book.class offers a perfect option to limit a number of supported properties to the ones known to be related to Books.</p><p>Bean Validation 1.1 can also be used.</p><h2 id="JAXRSSearch-Buildingthequeries">Building the queries</h2><h3 id="JAXRSSearch-FIQL">FIQL</h3><p>CXF 2.4.0 introduces <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/client/SearchConditionBuilder.java" rel="nofollow">SearchConditionBuilder</a> which makes it simpler to build FIQL queries. SearchConditionBuilder is an abstract class that returns a FIQL builder by default:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchConditionBuilder b = SearchConditionBuilder.instance();
String fiqlQuery = b.is("id").greaterThan(123).query();

WebClient wc = WebClient.create("http://books.com/search");
wc.query("_s", fiqlQuery);
// find all the books with id greater than 123 
Collection books = wc.getCollection(Book.class);
</pre>
</div></div><p>Here is an example of building more complex queries:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// OR condition
String ret = b.is("foo").greaterThan(20).or().is("foo").lessThan(10).query();
assertEquals("foo=gt=20,foo=lt=10", ret);

// AND condition
String ret = b.is("foo").greaterThan(20).and().is("bar").equalTo("plonk").query();
assertEquals("foo=gt=20;bar==plonk", ret);

// Complex condition
String ret = b.is("foo").equalTo(123.4).or().and(
            b.is("bar").equalTo("asadf*"), 
            b.is("baz").lessThan(20)).query();
assertEquals("foo==123.4,(bar==asadf*;baz=lt=20.0)", ret);
</pre>
</div></div><p>Note, starting from CXF 2.7.1 the following can be used to make connecting multiple primitive expressions simpler:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// AND condition, '.and("bar")' is a shortcut for "and().is("bar")", similar shortcut is supported for 'or'
String ret = b.is("foo").greaterThan(20).and("bar").equalTo("plonk").query();
assertEquals("foo=gt=20;bar==plonk", ret);
</pre>
</div></div><p>More updates to the builder API are available on the trunk:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// OR condition
String ret = b.is("foo").equalTo(20).or().is("foo").equalTo(10).query();
assertEquals("foo==20,foo==10", ret);

// Same query, shorter expression
String ret = b.is("foo").equalTo(20, 10).query();
assertEquals("foo==20,foo==10", ret);
</pre>
</div></div><p>and</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Connecting composite or() and and() expressions will add "()" implicitly:
String ret = b.is("foo").equalTo(20, 10).and("bar").lessThan(10).query();
assertEquals("(foo==20,foo==10);bar=lt=10", ret);

// wrap() method can be used to wrap explicitly:

String ret = b.is("foo").equalTo(10).and("bar").lessThan(10).wrap().or("bar").greaterThan(25).query();
assertEquals("(foo==20;bar=lt=10),bar=gt=25", ret);
</pre>
</div></div><p><br clear="none"></p><h2 id="JAXRSSearch-Usingdatesinqueries">Using dates in queries</h2><p>By default, the date values have to have the following <a shape="rect" class="external-link" href="http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html" rel="nofollow">format</a>: "yyyy-MM-dd", for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_search=date=le=2010-03-11
</pre>
</div></div><p>A custom date format can be supported. Use "search.date-format" contextual property, example, "search.date-format"="yyyy-MM-dd'T'HH:mm:ss" will let users type:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_search=time=le=2010-03-11T18:00:00
</pre>
</div></div><p>If needed, "search.timezone.support" can be enabled to get the timezones supported too.</p><p>At the moment, for custom date formats be recognized by SearchConditionBuilder, FIQLSearchConditionBuilder has to be created explicitly:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
props.put("search.date-format", "yyyy-MM-dd'T'HH:mm:ss");
props.put("search.timezone.support", "false");

Date d = df.parse("2011-03-01 12:34:00");
        
FiqlSearchConditionBuilder bCustom = new FiqlSearchConditionBuilder(props);
        
String ret = bCustom.is("foo").equalTo(d).query();
assertEquals("foo==2011-03-01T12:34:00", ret);
</pre>
</div></div><div class="action-body flooded"><p><br clear="none"></p><h3 id="JAXRSSearch-Relativedates">Relative dates</h3><p>Date value can be specified as a duration from the current date/time, as its string representation, "PnYnMnDTnHnMnS".<br clear="none">Resulted date will be calculated as a current date + specified duration. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_search=date=ge=-P90D
</pre>
</div></div><p><br clear="none"></p><p>This query will search for a date which is 90 days in the past or newer.</p></div><h2 id="JAXRSSearch-Alternativequerylanguages">Alternative query languages</h2><p>Custom org.apache.cxf.jaxrs.ext.search.SearchConditionParser implementations can be registered as a "search.parser" contextual property starting from CXF 3.0.0-milestone2.</p><h3 id="JAXRSSearch-OData">OData</h3><p><br clear="none"></p><p>Please use a "search.query.parameter.name" contextual property to indicate to the runtime that an OData '$filter' query option needs to be checked for the query expression and a "search.parser" property to point to the instance of org.apache.cxf.jaxrs.ext.search.odata.ODataParser, as shown in this <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerODataSearchTest.java">test</a>, see the startServers function.</p><p>And here is also an XML Spring configuration example (using SearchBean in this specific case):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> &lt;cxf:bus&gt;
  &lt;cxf:properties&gt;
    &lt;entry key="search.query.parameter.name" value="$filter" /&gt;
    &lt;entry key="search.parser"&gt;
      &lt;bean class="org.apache.cxf.jaxrs.ext.search.odata.ODataParser"&gt;
         &lt;constructor-arg value="#{ T(org.apache.cxf.jaxrs.ext.search.SearchBean) }" /&gt;
   &#160;  &lt;/bean&gt;
    &lt;/entry&gt;
  &lt;/cxf:properties&gt;
&lt;/cxf:bus&gt;
&#160;</pre>
</div></div><p><br clear="none"></p><p>Also note that <a shape="rect" class="external-link" href="http://olingo.incubator.apache.org/">Apache Olingo</a> offers its own visitor model which can be used to work with JPA2, etc.</p><h2 id="JAXRSSearch-ContentExtraction">Content Extraction</h2><p>Starting from CXF 3.0.2, the content extraction support has been added in order to complement the search capabilites with text extraction from various document formats (PDF, ODF, DOC,TXT,RTF,...). It is based on Apache Tika and is available in two shapes: raw content extraction (TikaContentExtractor) and Lucene document content extraction (TikaLuceneContentExtractor).</p><h3 id="JAXRSSearch-UsingTikaContentExtractor">Using&#160;TikaContentExtractor</h3><p>The purpose of Tika content extractor is to provide the essential support of text extraction from supported document formats. Additionally, the metadata is being extracted as well depending on the document format (author, modified, created, pages, ...). The TikaContentExtractor accepts the list of supported parsers and returns the extracted metadata together with the desired extracted content format (by default raw text). For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">TikaContentExtractor extractor = new TikaContentExtractor(new PDFParser(), true);
TikaContent content = extractor .extract( Files.newInputStream( new File( "testPDF.pdf" ).toPath() ) );</pre>
</div></div><p>By default, the TikaContentExtractor&#160; also performs the content type detection and validation, which could be turned off using the 'validateMediaType' constructor argument.</p><h3 id="JAXRSSearch-UsingTikaLuceneContentExtractor">Using&#160;TikaLuceneContentExtractor</h3><p>The TikaLuceneContentExtractor is very similar to TikaContentExtractor but instead of raw content and metadata it returns prepared Lucene document. However, in order to properly create the Lucene document which is ready to be indexed, TikaLuceneContentExtractor&#160; accepts an additional parameter, LuceneDocumentMetadata, with the field types and type converters. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">LuceneDocumentMetadata documentMetadata = new LuceneDocumentMetadata("contents").withField("modified", Date.class);
TikaLuceneContentExtractor extractor = new TikaLuceneContentExtractor(new PDFParser(), true);
Document document = extractor.extract( Files.newInputStream( new File( "testPDF.pdf" ).toPath() ), documentMetadata  );</pre>
</div></div><p>At this point, the document is ready to be analyzed and indexed. The TikaLuceneContentExtractor uses&#160;LuceneDocumentMetadata to create the properly typed document fields and currently supports DoubleField, FloatField, LongField, IntField,&#160;IntField,&#160;TextField (for content) and StringField (also used to store dates).</p><p>To demonstrate the full power of the CXF 3.0.2 content extraction and search capabiities, the demo project 'jax_rs_search' has been developed and is distributed in the samples bundle. The project could be found in the <a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/search" rel="nofollow">official Apache CXF Github repository</a>. It integrates together Apache CXF, Apache Lucene and Apache Tika showing off some advanced features related to custom analyzers and different filter criteria (keyword and&#160; phrase search).</p><pre><br clear="none"></pre></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </table>
   </td>
   <td id="cell-2-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
   <td id="cell-3-0">&nbsp;</td>
   <td id="cell-3-1">&nbsp;</td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">Privacy Policy</a> - 
         (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=30748414">edit page</a>) 
	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=30748414&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)<br>
	Apache CXF, CXF, Apache, the Apache feather logo are trademarks of The Apache Software Foundation.<br>
        All other marks mentioned may be trademarks or registered trademarks of their respective owners.
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3">&nbsp;</td>
   <td id="cell-3-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2">&nbsp;</td>
    <td id="cell-4-1">&nbsp;</td>
    <td id="cell-4-2" colspan="2">&nbsp;</td>
  </tr>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

