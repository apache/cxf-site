
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Data Bindings">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>
Apache CXF -- JAX-RS Data Bindings
    </title>
  </head>
<body onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td id="cell-0-0" colspan="2">&nbsp;</td>
    <td id="cell-0-1">&nbsp;</td>
    <td id="cell-0-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-1-0">&nbsp;</td>
    <td id="cell-1-1">&nbsp;</td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight: bold; font-size: 170%; color: white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="The Apache Sofware Foundation"><img border="0" alt="ASF Logo" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs -->
<a href="index.html">Index</a>&nbsp;&gt;&nbsp;<a href="restful-services.html">RESTful Services</a>&nbsp;&gt;&nbsp;<a href="jax-rs.html">JAX-RS</a>&nbsp;&gt;&nbsp;<a href="jax-rs-data-bindings.html">JAX-RS Data Bindings</a>
                <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">Download</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">Documentation</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </table>
      </div>
    </td>
    <td id="cell-1-3">&nbsp;</td>
    <td id="cell-1-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2">&nbsp;</td>
    <td id="cell-2-1">
      <table>
        <tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">Overview</a></li><li><a shape="rect" href="how-tos.html">How-Tos</a></li><li><a shape="rect" href="frontends.html">Frontends</a></li><li><a shape="rect" href="databindings.html">DataBindings</a></li><li><a shape="rect" href="transports.html">Transports</a></li><li><a shape="rect" href="configuration.html">Configuration</a></li><li><a shape="rect" href="debugging-and-logging.html">Debugging and Logging</a></li><li><a shape="rect" href="tools.html">Tools</a></li><li><a shape="rect" href="restful-services.html">RESTful Services</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL Bindings</a></li><li><a shape="rect" href="service-routing.html">Service Routing</a></li><li><a shape="rect" href="dynamic-languages.html">Dynamic Languages</a></li><li><a shape="rect" href="ws-support.html">WS-* Support</a></li><li><a shape="rect" href="advanced-integration.html">Advanced Integration</a></li><li><a shape="rect" href="deployment.html">Deployment</a></li><li><a shape="rect" href="schemas-and-namespaces.html">Use of Schemas and Namespaces</a></li></ul><hr><ul class="alternate"><li><p>Search</p></li></ul><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF Website</a></li></ul><p>&#160;</p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><span style="font-size:2em;font-weight:bold">JAX-RS : Data Bindings</span>


<br clear="none"></p><p><br clear="none"></p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1636141721596 {padding: 0px;}
div.rbtoc1636141721596 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1636141721596 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1636141721596">
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSDataBindings-JAXBsupport">JAXB support</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSDataBindings-ConfiguringtheJAXBprovider">Configuring the JAXB provider</a></li><li><a shape="rect" href="#JAXRSDataBindings-JAXBandMoxy">JAXB and Moxy</a></li></ul>
</li><li><a shape="rect" href="#JAXRSDataBindings-JSONsupport">JSON support</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSDataBindings-Jettison">Jettison</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSDataBindings-ConfiguringJSONprovider">Configuring JSON provider</a></li><li><a shape="rect" href="#JAXRSDataBindings-DealingwithJettisonarrayserializationissues">Dealing with Jettison array serialization issues</a></li><li><a shape="rect" href="#JAXRSDataBindings-BadgerFishconvention">BadgerFish convention</a></li><li><a shape="rect" href="#JAXRSDataBindings-WrappingandUnwrappingJSONsequences">Wrapping and Unwrapping JSON sequences</a></li><li><a shape="rect" href="#JAXRSDataBindings-TypeConverters">TypeConverters</a></li></ul>
</li><li><a shape="rect" href="#JAXRSDataBindings-Jackson">Jackson</a></li></ul>
</li><li><a shape="rect" href="#JAXRSDataBindings-CommonJAXBandJSONconfiguration">Common JAXB and JSON configuration</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSDataBindings-SingleJAXBContextandextrauserclasses">Single JAXBContext and extra user classes</a></li><li><a shape="rect" href="#JAXRSDataBindings-AutomaticJAXBElementconversionduringserialization">Automatic JAXBElement conversion during serialization</a></li><li><a shape="rect" href="#JAXRSDataBindings-HandlingJAXBbeanswithoutXmlRootElementannotations">Handling JAXB beans without XmlRootElement annotations</a></li><li><a shape="rect" href="#JAXRSDataBindings-Handlingexplicitcollections">Handling explicit collections</a></li></ul>
</li><li><a shape="rect" href="#JAXRSDataBindings-CustomizingJAXBXMLandJSONinputandoutput">Customizing JAXB XML and JSON input and output</a></li><li><a shape="rect" href="#JAXRSDataBindings-ControllingLargeJAXBXMLandJSONinputpayloads">Controlling Large JAXB XML and JSON input payloads</a></li><li><a shape="rect" href="#JAXRSDataBindings-JSR-353JSONProcessing">JSR-353 JSON Processing</a></li><li><a shape="rect" href="#JAXRSDataBindings-JSR-367JSONBinding">JSR-367 JSON Binding</a></li><li><a shape="rect" href="#JAXRSDataBindings-SimpleJsonMapObjectsupport">Simple JsonMapObject support</a></li><li><a shape="rect" href="#JAXRSDataBindings-JSONWithPadding(JSONP)">JSON With Padding (JSONP)</a></li><li><a shape="rect" href="#JAXRSDataBindings-Formpayloads">Form payloads</a></li><li><a shape="rect" href="#JAXRSDataBindings-Atom">Atom</a></li><li><a shape="rect" href="#JAXRSDataBindings-AegisDataBinding">Aegis Data Binding</a></li><li><a shape="rect" href="#JAXRSDataBindings-XMLBeans">XMLBeans</a></li><li><a shape="rect" href="#JAXRSDataBindings-CXFDataBindingsasJAX-RSproviders">CXF DataBindings as JAX-RS providers</a></li><li><a shape="rect" href="#JAXRSDataBindings-JAXRSDataBinding">JAXRS DataBinding</a></li><li><a shape="rect" href="#JAXRSDataBindings-Schemavalidation">Schema validation</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSDataBindings-Supportforcatalogs">Support for catalogs</a></li><li><a shape="rect" href="#JAXRSDataBindings-Outputvalidation">Output validation</a></li></ul>
</li><li><a shape="rect" href="#JAXRSDataBindings-BeanValidation">Bean Validation</a></li><li><a shape="rect" href="#JAXRSDataBindings-FastInfoset">Fast Infoset</a></li></ul>
</div><h1 id="JAXRSDataBindings-JAXBsupport">JAXB support</h1><p>The request and response can be marshalled and unmarshalled to/from a Java object using JAXB.</p><p>There are a number of ways to tell to the JAXB provider how objects can be serialized. The simplest way is to mark a given type with @XmlRootElement annotation.</p><p>For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@XmlRootElement(name = "Customer")
public class Customer {
    private String name;
    private long id;

    public Customer() {
    }

    public void setName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }

    public void setId(long i) {
        id = i;
    }

    public long getId() {
        return id;
    }
}
</pre>
</div></div><p>In the example below, the Customer object returned by getCustomer is marshalled using the JAXB data binding:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customerservice/")
public class CustomerService {
    @GET
    @Path("/customers/{customerId}/")
    public Customer getCustomer(@PathParam("customerId") String id) {
        ....
    }
}
</pre>
</div></div><p>The wire representation of the Customer object is:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;Customer&gt;
    &lt;id&gt;123&lt;/id&gt;
    &lt;name&gt;John&lt;/name&gt;
&lt;/Customer&gt;
</pre>
</div></div><p>The simplest way to work with collections is to define a type representing a collection. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@XmlRootElement(name = "Customers")
public class Customers {
    private Collection&lt;Customer&gt; customers;

    public Collection&lt;Customer&gt; getCustomer() {
        return customers;
    }

    public void setCustomer(Collection&lt;Customer&gt; c) {
        this.customers = c;
    }
}
@Path("/customerservice/")
public class CustomerService {
    @GET
    @Path("/customers/")
    public Customers getCustomers() {
        ....
    }
}
</pre>
</div></div><p>As an alternative to using @XmlRootElement and Collection wrappers, one can provide an Object factory which will tell JAXB how to marshal a given type (in case of Collections - its template type). Another option is to return/accept a JAXBElement directly from/in a given method.</p><p>Another option is to register one or more JAX-RS ContextResolver providers capable of creating JAXBContexts for a number of different types. The default JAXBElementProvider will check these resolvers first before attempting to create a JAXBContext on its own.</p><p>Finally, JAXBProvider provides support for serializing response types and deserializing parameters of methods annotated with @XmlJavaTypeAdapter annotations.</p><h2 id="JAXRSDataBindings-ConfiguringtheJAXBprovider">Configuring the JAXB provider</h2><p>The default JAXB provider can be configured in a number of ways. For example, here's how to configure marshal properties :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
        &lt;property name="marshallerProperties" ref="propertiesMap"/&gt;
    &lt;/bean&gt;
    &lt;util:map id="propertiesMap"&gt;
        &lt;entry key="jaxb.formatted.output"&gt;
            &lt;value type="java.lang.Boolean"&gt;true&lt;/value&gt;
        &lt;/entry&gt;
    &lt;/util:map&gt;
/&lt;beans&gt;
</pre>
</div></div><p>Individual marshal properties can be injected as simple properties. At the moment, Marshaller.JAXB_SCHEMA_LOCATION can be injected as the "schemaLocation" property. Schema validation can be enabled and custom @Consume and @Produce media types can be injected, see <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs/WEB-INF/beans.xml" rel="nofollow">this example</a> and the "Customizing media types for message body providers" and "Schema Validation" sections for more information.</p><p>One issue which one may need to be aware of it is that an exception may occur during the JAXB serialization process, after some content has already been processed and written to the output stream. By default, the output goes directly to the output HTTP stream so if an exception occurs midway through the process then the output will likely be malformed. If you set 'enableBuffering' property to 'true' then a JAXB provider will write to the efficient CXF CachedOutputStream instead and if an exception occurs then no text which has already been written will make it to the outside world and it will be only this exception that will be reported to the client.</p><p>When enabling buffering, you can also control how the data being serialized will be buffered. By default, an instance of CXF CachedOutputStream will be used. If you set an "enableStreaming" property on the JAXBElementProvider then it will be a CXF CachingXMLEventWriter that will cache the serialization events.</p><p>If you would like your own custom provider to write to a cached stream then you can either set an "org.apache.cxf.output.buffering" property to 'true' on a jaxrs endpoint or "enableBuffering" property on the provider. If this provider deals with XML and has a "getEnableStreaming" method returning 'true' then CachingXMLEventWriter will be used, in all other cases CachedOutputStream will be used.</p><p>Please note that if you don't have wrapper types for your methods and the classloader you are using does not allow you to call defineClass(), you may need to set '-Dcom.sun.xml.bind.v2.bytecode.ClassTailor.noOptimize'</p><p>JAXB Marshaller, Unmarshaller and context properties can be configured for both JAXB and JSON providers. Both providers can also be configured to skip the isReadable() and isWriteable() checks to do with asserting that a given instance is likely to be successfully read/written by setting a 'skipChecks' property to true. This can be useful when it is known that only valid JAXB instances are read or written.</p><p>Starting from CXF 2.4.3 it is possible to have specific prefixes associated with XML namespaces. This might be needed to make legacy consumers able to consume the resulting XML. Use a "namespacePrefixes" map property (namespace is a key, corresponding prefix is a value).</p><h2 id="JAXRSDataBindings-JAXBandMoxy">JAXB and Moxy</h2><p>For JAXBElementProvider to support <a shape="rect" class="external-link" href="http://www.eclipse.org/eclipselink/#moxy" rel="nofollow">Moxy</a> a custom Moxy-aware JAX-RS ContextProvider implementation needs to be registered in jaxrs:providers. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.ws.rs.ext.ContextResolver;
import org.eclipse.persistence.jaxb.JAXBContextFactory;

public class MoxyJaxbContextResolved implements ContextResolver&lt;JAXBContext&gt; {

  JAXBContextFactory factory = new JAXBContextFactory();

  public JAXBContext getContext(Class&lt;?&gt; cls) {
      try {
          return JAXBContextFactory.createContext(new Class[] {cls}, null);
      } catch (JAXBException ex) {
          throw new RuntimeException(ex);
      }
  }

}
</pre>
</div></div><p>Alternatively, add a "jaxb.properties" file with the entry "javax.xml.bind.context.factory=org.eclipse.persistence.jaxb.JAXBContextFactory" to a package where the JAXB beans are located.</p><p>If Moxy is used to handle beans without JAXB annotations then setting a 'skipJaxbChecks' property on JAXBElementProvider to 'true' will be needed.</p><p>Use JAXBElementProvider "namespaceMapperPropertyName" and "xmlPiPropertyName" properties if you need to customize namespace prefixes or add XML processing instructions with Moxy. JSONProvider will also recognize "namespaceMapperPropertyName" in cases when the namespaces are not ignored.</p><h1 id="JAXRSDataBindings-JSONsupport">JSON support</h1><p>The following code returns a Customer object that is marshaled to JSON format:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customerservice/")
public class CustomerService {
    @Produces("application/json")
    @GET
    @Path("/customers/{customerId}/")
    public Customer getCustomer(@PathParam("customerId") String id) {
        ....
    }
} </pre>
</div></div><h2 id="JAXRSDataBindings-Jettison">Jettison</h2><h3 id="JAXRSDataBindings-ConfiguringJSONprovider">Configuring JSON provider</h3><p>The default JSON provider relies on Jettison 1.4.0 and it expects the types it deals with to follow the same techniques as described above in the JAXB support section for them to be handled properly.</p><p>The default JSON provider can be configured in a number of ways. For example, here's how to set up namespace-to-prefix mappings :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.json.JSONProvider"&gt;
        &lt;property name="namespaceMap" ref="jsonNamespaceMap"/&gt;
    &lt;/bean&gt;
    &lt;util:map id="jsonNamespaceMap" map-class="java.util.Hashtable"&gt;
        &lt;entry key="http://www.example.org/books" value="b"/&gt;
    &lt;/util:map&gt;
/&lt;beans&gt;
</pre>
</div></div><p><strong>Note</strong> that starting from CXF 2.3.0 it may not be needed to set up a custom namespace map on the write side with JSONProvider making a 'best' effort to retrieve them during the JAXB Marshaller calls. Starting from CXF 2.6.1 and 2.5.4 setting the namespace maps will additionally configure a Marshaller namespace mapper.</p><p>Schema validation can be enabled and custom @Consume and @Produce media types can be injected, see <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs/WEB-INF/beans.xml" rel="nofollow">this example</a> and "Customizing media types for message body providers" and "Schema Validation" sections for more information.</p><p><strong>Note</strong> that JSONProvider is Jettison based and supports only JAXB annotated beans. You should use Jackson provider to process POJOs without JAXB annotations.</p><h3 id="JAXRSDataBindings-DealingwithJettisonarrayserializationissues">Dealing with Jettison array serialization issues</h3><p>By default, Jettison wrongly serializes List objects containing a single value only. To work around this issue, one needs to enable a 'serializeAsArray' feature on a JSONProvider, with the additional option of specifying the individual fields which needs to be processed accordingly using an 'arrayKeys' property. Please see <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs/WEB-INF/beans.xml" rel="nofollow">this example</a> for more information.</p><p>Note that 'serializeAsArray' and 'arrayKeys' can be combined to produce so called natural convention sequences. For example, given the following two class definitions :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@XmlRootElement()
@XmlType(name = "", propOrder = {"title", "comments" })
public static class Post {
    private String title;
    private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();
    public void setTitle(String title) {
        this.title = title;
    }
    public String getTitle() {
        return title;
    }
    public void setComments(List&lt;Comment&gt; comments) {
        this.comments = comments;
    }
    public List&lt;Comment&gt; getComments() {
        return comments;
    }
}
   
public static class Comment {
     private String title;

     public void setTitle(String title) {
        this.title = title;
     }

     public String getTitle() {
         return title;
     }
} 
</pre>
</div></div><p>an instance of Post class can be serialized like this if a JSONProvider has had its 'serializeAsArray' property set to 'true' and 'arrayKeys' list property set to contain 'comments' value :</p><p>&gt; {"post":{"title":"post","comments":[{"title":"comment1"},{"title":"comment2"}]}}</p><p>One other property which might help during the serialization is a boolean "ignoreMixedContent" property which allows you to bypass a Jettison issue to do with outputting '$' properties when dealing with empty strings typically encountered in mixed content trees.</p><p>You may request that JSONProvider ignores an 'xsi:type' attribute which is serialized in some cases by setting a "writeXsiType" boolean property with a 'false' value.</p><p>You may also request that JSONProvider ignores all the namespaces during the serialization process by setting an "ignoreNamespaces" boolean property with a 'true' value.</p><p>Starting from CXF 2.7.6 (and Jettison 1.3.4):</p><ul class="alternate"><li>'writeNullAsString' property can be used to affect the way Jettison writes out null values, if this property is set to 'false' then Jettison will write null values without wrapping them in double quotes.</li><li>new 'dropElementsInXmlStream' can be set to false and be used with outDropElements property to affect the serialization directly at the Jettison level</li></ul><h3 id="JAXRSDataBindings-BadgerFishconvention">BadgerFish convention</h3><p>Starting from CXF 2.2.5 it is possible to configure JSONProvider to support a BadgerFish convention. By default a "mapped" convention is supported, set a JSONProvider "convention" property with the value "badgerfish" if you'd like to work with the BadgerFish convention.</p><h3 id="JAXRSDataBindings-WrappingandUnwrappingJSONsequences">Wrapping and Unwrapping JSON sequences</h3><p>A "wrapperName" string property can be used to append a dropped root element name to an incoming JSON sequence for it to be deserialized properly. A "wrapperMap" map property can be used to nominate wrapper names for individual class names. In both cases, a 'supportUnwrapped' boolean property also has to be set.</p><p>A boolean "dropRootName" property can be used to tell JSONProvider that a root element needs to be dropped.</p><h3 id="JAXRSDataBindings-TypeConverters">TypeConverters</h3><p>Jettison 1.2 supports the registration of org.codehaus.jettison.mapped.TypeConverter implementations which can be used to convert types to JSON primitives. The "typeConverter" property can be used to register a converter with JSONProvider instance. The "convertTypesToStrings" property can be used to configure JSONProvider to convert all the types to strings.</p><h2 id="JAXRSDataBindings-Jackson">Jackson</h2><p>If you prefer working with Jackson JSON providers then register either JacksonJsonProvider:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:providers&gt;
   &lt;bean class="org.codehaus.jackson.jaxrs.JacksonJsonProvider"/&gt;
&lt;/jaxrs:providers&gt;
</pre>
</div></div><p>or JacksonJaxbJsonProvider (when working with JAXB beans):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:providers&gt;
   &lt;bean class="org.codehaus.jackson.jaxrs.JacksonJaxbJsonProvider"/&gt;
&lt;/jaxrs:providers&gt;
</pre>
</div></div><p>and add this Maven dependency:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.jaxrs&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-jaxrs-json-provider&lt;/artifactId&gt;
  &lt;version&gt;2.9.3&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><h1 id="JAXRSDataBindings-CommonJAXBandJSONconfiguration">Common JAXB and JSON configuration</h1><p>In this section it's expected that Jettison is used to handle JSON.</p><h2 id="JAXRSDataBindings-SingleJAXBContextandextrauserclasses">Single JAXBContext and extra user classes</h2><p>By default JAXBContexts are created on demand. Starting from CXF 2.3.2 and 2.4.0 it is possible to configure JAXB-based providers to support the creation of a single JAXBContext, example :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxb" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
      &lt;property name="singleJaxbContext" value="true"/&gt;
      &lt;property name="extraClass"&gt;
         &lt;list&gt;
           &lt;value&gt;org.apache.cxf.jaxrs.resources.SuperBook&lt;/value&gt;
           &lt;value&gt;org.apache.cxf.jaxrs.resources.SuperBook&lt;/value&gt;  
         &lt;/list&gt;
      &lt;/property&gt;
&lt;/bean&gt;
</pre>
</div></div><p>Please note that if an extraClass property is set then the JAXBContext (single as in the above example or the one created dynamically on a per-class or per-package basis) will also include the extra user classes thus making it possible to avoid setting an XmlSeeAlso JAXB annotation or dealing with JAXB jaxb.index or ObjectFactory resources. This property is identical to a CXF JAXBDataBinding 'extraClass' property.</p><p>Trying to create a single JAXBContext is also an optimization step. Having a single JAXBContext for classes the JAX-RS runtime can statically discover by checking all the root resources and their sub-resources (assuming the jaxrs:server endpoint has been configured to do the static resolution of the sub-resources) does not preclude JAX-RS Responses wrapping JAXB beans being used as well.</p><p>One may want to use the "singleJaxbContext" property in combination with the "skipChecks" property if it is known that only valid JAXB beans will be read or written.</p><p>Also note that setting only "extraClass", without setting "singleJaxbContext" property will also work in cases when no package JAXB contexts are created (specifically when no ObjectFactory or jaxb.index have been found). Starting from CXF 2.7.2 and 2.6.4 it will also work well for package contexts.</p><p>However, when possible, prefer always setting both "singleJaxbContext" and "extraClass" properties. Starting from CXF 2.7.2 this will also work well for package-level contexts - add "useSingleContextForPackages" property to get the created single context always used as a package context.</p><h2 id="JAXRSDataBindings-AutomaticJAXBElementconversionduringserialization">Automatic JAXBElement conversion during serialization</h2><p>In some cases, wrapping object instances into JAXBElements may affect the way XML is produced. For example, given Base and Derived classes, returning an instance of Derived class, with Base one being a method response type, would produce an additional xsi:type attribute if this instance is wrapped into JAXBElement. One can set a "jaxbElementClassNames" list property which can contain class names like "org.foo.Base", etc.</p><h2 id="JAXRSDataBindings-HandlingJAXBbeanswithoutXmlRootElementannotations">Handling JAXB beans without XmlRootElement annotations</h2><p>A "jaxbElementClassNames" list property mentioned in the previous section can affect the serialization of objects of types with XmlRootElement annotations.<br clear="none">In some cases no XmlRootElement annotations are available on types and adding them manually may not be an option; likewise having explicit JAXBElements in method signatures may also be seen as too intrusive.</p><p>In such cases, one might want to use a "jaxbElementClassMap" map property which contains class name to simple or expanded QName pairs. This will also lead to the automatic JAXBElement conversion durring the serialization. Finally, 'marshalAsJaxbElement' boolean property can be used when all the instances need to be wrapped - provided that simple class names of these instances can be used as element names.</p><p>When deserializing, one can either update an existing ObjectFactory with methods returning JAXBElements or simply set an 'unmarshalFromJaxbElement' property on either JAXB or JSON provider.</p><h2 id="JAXRSDataBindings-Handlingexplicitcollections">Handling explicit collections</h2><p>JAXB and JSON providers can handle explicit collections like List, Set or base Collection.<br clear="none">By default they will try to deduce the name of the collection root element from a collection member class. For example, given a Book.class whose @XmlRootElement value is 'Book', the name of the collection name will be 'Books'.<br clear="none">One can override it by setting a 'collectionWrapperName' string property, like 'Books' or '{<span class="nolink">http://books</span>}Book'.</p><p>There's also a 'collectionWrapperMap' property available for use in more advanced cases, when collections of different types are used, for example, when mixed collections of objects descended from abstract classes having no @XmlRootElement tags are returned :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;!-- Configure JAXB Provider --&gt;
&lt;bean id="jaxbProvider"
    class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
    &lt;property name="collectionWrapperMap"&gt;
        &lt;map&gt;
            &lt;entry&gt;
                &lt;key&gt;&lt;value&gt;com.foo.bar.MyObject&lt;/value&gt;&lt;/key&gt;
                &lt;value&gt;MyObjects&lt;/value&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><p>JSONProvider can only serialize explicit collections at the moment. If needed, it can be told to drop a collection element name using a boolean 'dropCollectionWrapperElementName'. For example, a 'dropCollectionWrapperElementName' and 'serializeAsArray' properties can be used to make the Pojo JSON RestStore consume the resulting JSON sequence (in CXF 2.2.5).</p><h1 id="JAXRSDataBindings-CustomizingJAXBXMLandJSONinputandoutput">Customizing JAXB XML and JSON input and output</h1><p>Sometimes you may want to adapt an incoming XML request or outgoing XML response. For example, your application has changed but a lot of legacy clients have not been updated yet.<br clear="none">When dealing with XML, the easiest and fastest option is to register a custom STAX XMLStreamWriter or XMLStreamReader and modify XML as needed. You can register a custom STAX <br clear="none">handler from RequestHandler or ResponseHandler filters or input/output CXF interceptors. For example, see <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/XmlStreamWriterProvider.java" rel="nofollow">XMLStreamWriterProvider</a> and <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/CustomXmlStreamWriter.java" rel="nofollow">CustomXmlStreamWriter</a>.</p><p>Another option is to register a custom JAXB or JSON provider extending CXF JAXBElementProvider or JSONProvider and overriding a method like createStreamWriter(). <br clear="none">Typically one would delegate to a super class first and then wrap the returned writer in a custom writer, see <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/CustomXmlStreamWriter.java" rel="nofollow">CustomXmlStreamWriter</a> for an example.</p><p>One can also use XSLTJaxbProvider to produce or modify the incoming XML. In fact, XSLTJaxbProvider can be used to adapt formats like JSON for legacy consumers.</p><p>Please also see this <a shape="rect" class="external-link" href="http://soa.dzone.com/articles/pragmatic-web-services-apache" rel="nofollow">overview</a> of various related features available in CXF.</p><p>In CXF 2.2.5, a new feature has been introduced whose goal is to generalize and simplify in a number of cases the way both JAXB and JSON can be customized.</p><p>Note that starting from CXF 2.4.0 the new <a shape="rect" href="transformationfeature.html">Transformation Feature</a> can be used instead.</p><p>The following configuration properties have been added to the base JAXB/JSON AbstractJAXBProvider :</p><ul class="alternate"><li>"outTransformElements" map property: can be used to change the output element names and change or drop namespaces; keys are the elements to be changed, values are the new element names. Examples:</li></ul><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="outTransformElements"&gt;
    &lt;map&gt;
      &lt;!-- change "book" to "thebook" --&gt;
      &lt;entry key="book" value="thebook"/&gt;
      
      &lt;!-- drop the namespace from "book" --&gt;
      &lt;entry key="{http://books}book" value="book"/&gt; 
      
      &lt;!-- qualify "book" with "http://books" --&gt;
      &lt;entry key="book" value="{http://books}thebook"/&gt; 
      
      &lt;!--  change namespace to "http://books" for all the elements with the "http://book" namespace --&gt;
      &lt;entry key="{http://book}*" value="{http://books}*"/&gt; 
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><ul class="alternate"><li>"inTransformElements" map property: can be used to change the input element names and change or drop namespaces; see the "outTransfromElements" property description for an example.</li></ul><ul class="alternate"><li>"outAppendElements" map property: can be used to append new simple or qualified elements to the output; keys are the new elements, values are the elements the new ones will be appended before. Examples:</li></ul><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="outAppendElements"&gt;
    &lt;map&gt;
      &lt;!-- append "book" before "thebook" --&gt;
      &lt;entry key="book" value="thebook"/&gt;
      
      &lt;!-- qualify "book" with "http://books" --&gt;
      &lt;entry key="{http://books}book" value="book"/&gt; 
      
      &lt;!-- drop the namespace from the "book" --&gt;
      &lt;entry key="book" value="{http://books}thebook"/&gt; 
      
      &lt;!--  change namespace to "http://book" for all the elements with the "http://books" namespace --&gt;
      &lt;entry key="{http://book}*" value="{http://books}*"/&gt; 
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><ul class="alternate"><li>"inAppendElements" map property : can be used to append new simple or qualified elements to the input; see the "outAppendElements" property description for an example.</li></ul><ul class="alternate"><li>"outDropElements" list property : can be used to drop elements during the serialization; note that children elements if any of a given dropped element are not affected. Examples:</li></ul><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="outDropElements"&gt;
    &lt;list&gt;
      &lt;!-- ignore drop and {http://numbers}number elements --&gt;
      &lt;value&gt;{http://numbers}number&lt;/value&gt;
      &lt;value&gt;index&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><ul class="alternate"><li>"inDropElements" list property : can be used to drop elements during the deserialization; note that children elements if any of a given dropped element are not affected. Please see the "outDropElements" property description for an example.</li></ul><ul class="alternate"><li>"attributesAsElements" boolean property : can be used to have attributes serialized as elements.</li></ul><p>The combination of "attributesAsElements" and "outDropElements" properties can be used to have certain attributes ignored in the output by turning then into elements first and then blocking them.</p><p>This feature might be used in a number of cases. For example, one may have rootless JSON array collections such as "<code>a:b},{c:d</code>" deserialized into a bean by using a "wrapperName" JSONProvider property with a value like "list" which identifies a bean field and an "inAppendMap" property with a name of the bean (ex, "book") being appended before the "list", thus effectively turning the original JSON sequence into "{book:{list:<code>a:b},{c:d</code>}}".</p><h1 id="JAXRSDataBindings-ControllingLargeJAXBXMLandJSONinputpayloads">Controlling Large JAXB XML and JSON input payloads</h1><p>Starting from CXF 2.6.0 it is possible to control the depth of large XML and JSON payloads on the per-endpoint basis in order to limit the risk of the denial of service attacks. Please see <a shape="rect" href="securing-cxf-services.html">this section</a> on how to use a new DepthRestrictingInterceptor in order to control XML payloads which are read either by JAXBElementProvider or SourceProvider (which supports JAXP Source and DOM Document types).</p><p>Additionally it is possible to configure JAXBElementProvider or JSONProvider with contextual properties or <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/core/src/main/java/org/apache/cxf/staxutils/DocumentDepthProperties.java" rel="nofollow">DocumentDepthProperties</a>:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="depthProperties" class="org.apache.cxf.staxutils.DocumentDepthProperties"&gt;
  &lt;property name="innerElementCountThreshold" value="500"/&gt;
&lt;/bean&gt; 

&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="depthProperties" ref="depthProperties"/&gt;
&lt;/bean&gt; 

&lt;bean id="jsonProvider" class="org.apache.cxf.jaxrs.provider.json.JSONProvider"&gt;
  &lt;property name="depthProperties" ref="depthProperties"/&gt;
&lt;/bean&gt; 

&lt;jaxrs:server id="endpoint1"&gt;
  &lt;jaxrs:serviceBeans&gt;
    &lt;bean class="my.package.RootResource"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
  &lt;jaxrs:providers&gt;
    &lt;ref bean="jaxbProvider"/&gt;
    &lt;ref bean="jsonProvider"/&gt;
  &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;

&lt;jaxrs:server id="endpoint2"&gt;
  &lt;jaxrs:serviceBeans&gt;
    &lt;bean class="my.package.RootResource"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
  &lt;jaxrs:properties&gt;
    &lt;entry key="depthInnerElementCountThreshold" value="500"/
  &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><h1 id="JAXRSDataBindings-JSR-353JSONProcessing">JSR-353 JSON Processing</h1><p>As per JAX-RS 2.0 specification, the support of <a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=353" rel="nofollow">JSR-353 Java API for JSON Processing</a> is mandatory requirement and implies the presence of message body reader(s)/writer(s) for following types: <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonStructure.html" rel="nofollow">JsonStructure</a>, <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonArray.html" rel="nofollow">JsonArray</a> and <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonObject.html" rel="nofollow">JsonObject</a>. Apache CXF provides such a support in a form of <strong>JsrJsonpProvider</strong> provider distributed by Apache CXF JAX-RS Extensions Providers module<strong> (cxf-rt-rs-extension-providers).</strong></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:providers&gt;
   &lt;bean class="org.apache.cxf.jaxrs.provider.jsrjsonp.JsrJsonpProvider"/&gt;
&lt;/jaxrs:providers&gt;
</pre>
</div></div><p>Adding <strong>JsrJsonpProvider</strong> provider alone (or in a combination with other providers) allows JAX-RS resources to natively use <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonStructure.html" rel="nofollow">JsonStructure</a>, <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonArray.html" rel="nofollow">JsonArray</a>, <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonObject.html" rel="nofollow">JsonObject</a> as input parameters or return values. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/books")
@Produces(MediaType.APPLICATION_JSON)
public JsonArray getBooks() {
    // Implementation here
}

@GET
@Path("/books/{bookId}")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject getBook(@PathParam("bookId") Long id) {
    // Implementation here
}

@POST
@Path("/books")
@Consumes(MediaType.APPLICATION_JSON)
public Response addBook(@Context final UriInfo uriInfo, JsonObject obj) {
    // Implementation here
}</pre>
</div></div><p>The <strong>JsrJsonpProvider</strong> provider could be used on server side or on a client side. By default, the provider uses <a shape="rect" class="external-link" href="https://jsonp.java.net/" rel="nofollow">JSR-353 Java API for JSON Processing reference implementation</a> to read/write message bodies.</p><h1 id="JAXRSDataBindings-JSR-367JSONBinding">JSR-367 JSON Binding</h1><p>As per JAX-RS 2.1 specification, the support of&#160;<a shape="rect" class="external-link" href="https://jcp.org/en/jsr/detail?id=367" rel="nofollow">JSR 367: Java API for JSON Binding (JSON-B)</a> is desired requirement and implies the presence of message body reader(s)/writer(s) for Java types supported by <a shape="rect" class="external-link" href="https://jcp.org/en/jsr/detail?id=367" rel="nofollow">JSON-B</a>. Apache CXF provides such a support in a form of <strong>JsrJsonbProvider</strong> provider distributed by Apache CXF JAX-RS Extensions Providers module<strong> (cxf-rt-rs-extension-providers).</strong></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:providers&gt;
   &lt;bean class="org.apache.cxf.jaxrs.provider.jsrjsonb.JsrJsonbProvider"/&gt;
&lt;/jaxrs:providers&gt;
</pre>
</div></div><p>Adding <strong>JsrJsonbProvider</strong> providers also covers <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonStructure.html" rel="nofollow">JsonStructure</a>, <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonArray.html" rel="nofollow">JsonArray</a>, <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonObject.html" rel="nofollow">JsonObject</a> as input parameters or return values.</p><h1 id="JAXRSDataBindings-SimpleJsonMapObjectsupport">Simple JsonMapObject support</h1><p>org.apache.cxf.jaxrs.provider.json.JsonMapObjectProvider is available starting from CXF 3.0.3 and CXF 3.1.0. This provider can read or write JSON into/from org.apache.cxf.jaxrs.provider.json.JsonMapObject which is a simple Map wrapper.</p><p>JsonMapObject can detect duplicate JSON sibling properties which can be useful in certain applications.</p><h1 id="JAXRSDataBindings-JSONWithPadding(JSONP)">JSON With Padding (JSONP)</h1><p>One option for supporting "JSON With Padding" (<a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/JSONP" rel="nofollow">JSONP</a>) is to extend the default JSONProvider and override its writeTo method as follows:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces("application/javascript")
class JsonpProvider extends JSONProvider {
		
    @Override
    public void writeTo(Object obj, Class&lt;?&gt; cls, Type genericType, Annotation[] anns, MediaType m, 
                        MultivaluedMap&lt;String, Object&gt; headers, OutputStream os) throws IOException {
	    String prefix = getContext().getHttpServletRequest().getParameter("_jsonp");
	    boolean hasPrefix = !isEmpty(prefix);
	    if(hasPrefix) {
	        os.write(prefix.getBytes(HttpUtils.getSetEncoding(m, headers, "UTF-8")));
	        os.write('(');
	    }
	    super.writeTo(obj, cls, genericType, anns, m, headers, os);
	    if(hasPrefix) {
		    os.write(')');
	    }
    }
}
</pre>
</div></div><p>A similar approach can work when Jackson is used.</p><p>Alternatively, a custom servlet filter can be used to support JSONP.</p><p>Starting from CXF 2.3.4 and 2.4.0, JSONP can be supported with the help of CXF in/out interceptors:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="bookJsonp" address="/jsonp"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="serviceBean" /&gt;
    &lt;/jaxrs:serviceBeans&gt;		  

    &lt;jaxrs:inInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpInInterceptor"/&gt;
    &lt;/jaxrs:inInterceptors&gt;
    &lt;jaxrs:outInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPreStreamInterceptor"/&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPostStreamInterceptor"/&gt;
    &lt;/jaxrs:outInterceptors&gt; 
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>JsonpInInterceptor checks if a JSONP callback query parameter is available (default is _jsonp) and if yes then it saves its value on the current exchange for out interceptors to know if they have to write the paddings or not. The name of the expected callback parameter can be customized. JsonpPreStreamInterceptor and JsonpPostStreamInterceptor ensure the actual JSON stream is 'padded' properly. JsonpPreStreamInterceptor will also set Content-Type to "application/x+javascript" by default but this can be changed:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="bookJsonp" address="/jsonp"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="serviceBean" /&gt;
    &lt;/jaxrs:serviceBeans&gt;		  

    &lt;jaxrs:inInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpInInterceptor"&gt;
          &lt;property name="callbackParam" value="myjsonp"/&gt;
       &lt;/bean&gt; 
    &lt;/jaxrs:inInterceptors&gt;
    &lt;jaxrs:outInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPreStreamInterceptor"&gt;
           &lt;property name="mediaType" value="text/x+javascript"/&gt;
       &lt;/bean&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPostStreamInterceptor"&gt;
           &lt;!-- default is ');' --&gt;
           &lt;property name="paddingEnd" value=")"/&gt;
       &lt;/bean&gt;
    &lt;/jaxrs:outInterceptors&gt; 
&lt;/jaxrs:server&gt;
</pre>
</div></div><h1 id="JAXRSDataBindings-Formpayloads">Form payloads</h1><p>A Form payload is a sequence of name and value pairs, example, "name=Barry&amp;age=20".<br clear="none">One can capture the form data by using either JAX-RS FormParam annotation or MultivaluedMap, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.ws.rs.FormParam;
import javax.ws.rs.MultivaluedMap;

@Path("resource")
public class FormResource {

   @POST
   @Path("/form1")
   @Consumes("application/x-www-form-urlencoded")
   public void form1(@FormParam("name") String name, @FormParam("age") int age) {
   }

   @POST
   @Path("/form2")
   @Consumes("application/x-www-form-urlencoded")
   public void form1(MultivaluedMap&lt;String, String&gt; params) {
       String name = params.getFirst("name");
       String age = params.getFirst("age");
   }

}
</pre>
</div></div><p>Note that it is possible to control the maximum number of the expected form parameters by setting a "maxFormParameterCount" contextual property (set within the jaxrs:properties). The client will receive HTTP 413 if the limit is reached.</p><h1 id="JAXRSDataBindings-Atom">Atom</h1><p>CXF JAXRS offers users 3 options for dealing with Atom</p><p>1. Register Apache Abdera based Feed and/or Entry providers (org.apache.cxf.jaxrs.ext.provider.atom.AtomFeedProvider and org.apache.cxf.jaxrs.ext.provider.atom.AtomEntryProvider) with a jaxrs endpoint and have resource methods explicitly dealing with Abdera Feed or Entry classes. This is the most advanced option in that it lets users build Feeds or Entries in the way which suits most. Note that Abdera has not been actively mantained recently but practically speaking it is very good for working with most of the cases one may have to deal with when developing Atom-based applications.</p><p>Both AtomFeedProvider and AtomEntryProvider support a 'formattedOutput' (pretty-printing) property.</p><p>2. Register an <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AtomPojoProvider.java" rel="nofollow">AtomPojoProvider</a> injected with either <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AtomElementWriter.java" rel="nofollow">AtomElementWriter</a> or <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AtomElementReader.java" rel="nofollow">AtomElementReader</a> implementations parameterized by either Abdera Feed or Entry and type of object which will have to be converted to/read from Feed/Entry.</p><p>For example, BookAtomElementWriter&lt;Feed, Book&gt; will be responsible for converting Book instances into Feeds while ChapterAtomElementWriter&lt;Entry, Chapter&gt; will be responsible for converting Chapter instances into Entries.</p><p>AtomElementWriter and AtomElementReader are injected using 'atomWriters' and 'atomReaders' map properties, where the keys are class names of the objects to be converted to/read from Feed or Entries, ex "org.apache.cxf.systest.jaxrs.Book".</p><p>AtomPojoProvider offers users a way to have no Abdera Feed/Entry classes referenced from the 'main' application code, example :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("books")
public class BooksRootResource {

    private Books books;

    @GET
    @Produces({"application/xml", "application/json", "application/atom+xml;type=feed"})
    public Books getCollectionOfBooks() {
        return books;
    } 

    @GET
    @Produces({"application/xml", "application/json", "application/atom+xml;type=entry"})
    @Path("{id}")
    public Book getBook(@PathParam("id") Long id) {
        return books.get(id);
    }
}
</pre>
</div></div><p>Note that when an object such as Books is about to be converted to/read from Feed (which in our case is essentially a collection of entries each of them representing an individual Book) the AtomPojoProvider needs to know about the collection getters and/or setters so that it can create individual Entries. The "collectionGetters" and "collectionSetters" map properties with keys being the names of collection classes and values being the method names need to be used for providing this information, example a pair "org.apache.cxf.systest.jaxrs.Books:getBooks" tells AtomPojoProvider that when creating a Books Feed, the objects representing individual entries can be retrieved from Book with the help of "getBooks". If these properties are not set then AtomPojoProvider will try to get a method adding the simple class name to either 'get' or 'set', for example, an "org.apache.cxf.systest.jaxrs.Books:getBooks" pair is redundant if the Books class has a getBooks method.</p><p>3. This option is nearly identical to the option 2, except that users configure AtomPojoProvider with concrete implementations of either <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AbstractFeedBuilder.java" rel="nofollow">AbstractFeedBuilder</a> or <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AbstractEntryBuilder.java" rel="nofollow">AbstractEntryBuilder</a>.</p><p>The difference is that in this case users have no explicit dependencies in their code on Atom-aware libraries such as Abdera - it may make it easier to experiment with various Atom libraries.</p><h1 id="JAXRSDataBindings-AegisDataBinding">Aegis Data Binding</h1><p>Use org.apache.cxf.provider.AegisElementProvider to start doing Aegis with JAX-RS<br clear="none">org.apache.cxf.provider.AegisJSONProvider can be used to output JSON with the help of Aegis.<br clear="none">Similarly to the default JSONProvider this Aegis-based JSON provider can have "namespaceMap", "serializeAsArray", "arrayKeys", "dropRootElement" and "writeXsiType" properties set.</p><h1 id="JAXRSDataBindings-XMLBeans">XMLBeans</h1><p>Use org.apache.cxf.provider.XmlBeansElementProvider to start doing XmlBeans with JAX-RS</p><h1 id="JAXRSDataBindings-CXFDataBindingsasJAX-RSproviders">CXF DataBindings as JAX-RS providers</h1><p>Starting from CXF 2.2.3 it is possible to register a CXF DataBinding bean using a jaxrs:databinding element and it will be wrappped as a JAXRS MessageBodyReader/Writer <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/DataBindingProvider.java" rel="nofollow">DataBindingProvider</a> capable of dealing with XML-based content. It can be of special interest to users combining JAX-RS and JAXWS. Thus CXF JAXB, JIBX, Aegis, SDO and XMLBeans DataBindings can be plugged in.</p><p>DataBindingProvider can also be registered as a jaxrs:provider with its dataBinding property being set as needed.</p><p>JSON support is also provided for all these databindings by <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/json/DataBindingJSONProvider.java" rel="nofollow">DataBindingJSONProvider</a>.<br clear="none">Please see <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs_databinding/WEB-INF/beans.xml" rel="nofollow">this configuration file</a> for some examples.</p><p>Similarly to the default JSONProvider the DataBindingJSONProvider JSON provider can have "namespaceMap", "serializeAsArray", "arrayKeys", "dropRootElement" and "writeXsiType" properties set. Additionally it may also have an "ignoreMixedContent" property set.</p><p>Starting from CXF 2.4.0 and CXF 2.3.2 a CXF <a shape="rect" href="annotations.html">DataBinding</a> annotation is also supported.</p><h1 id="JAXRSDataBindings-JAXRSDataBinding">JAXRS DataBinding</h1><p><strong>Available starting from CXF 2.3.2 and CXF 2.4.0</strong></p><p>org.apache.cxf.jaxrs.provider.JAXRSDataBinding is a CXF DataBinding implementation which wraps JAX-RS providers and can be used by CXF JAX-WS endpoints thus making it possible to use JAX-RS providers for reading and writing XML payloads during SOAP and RESTful invocations. Example :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="hello_rest" address="/hello-rest"&gt;
    &lt;jaxrs:serviceBeans&gt;
        &lt;bean class="org.apache.cxf.systest.jaxrs.jaxws.HelloWorldImpl"/&gt;
    &lt;/jaxrs:serviceBeans&gt;

    &lt;jaxrs:providers&gt;
        &lt;ref bean="jaxbProviderSoap"/&gt;
    &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;

&lt;jaxws:endpoint xmlns:s="http://hello.com"
    serviceName="s:HelloWorld"
    endpointName="s:HelloWorldPort"
    id="hello_soap-databinding"
    implementor="org.apache.cxf.systest.jaxrs.jaxws.HelloWorldImpl"
    address="/hello-soap-databinding"&gt;
      
    &lt;jaxws:dataBinding&gt;
        &lt;ref bean="jaxrs-data-binding"/&gt;
    &lt;/jaxws:dataBinding&gt;
      
&lt;/jaxws:endpoint&gt;        
 
&lt;bean id="jaxrs-data-binding" class="org.apache.cxf.jaxrs.provider.JAXRSDataBinding"&gt;
    &lt;property name="provider" ref="jaxbProviderSoap"/&gt;
&lt;/bean&gt;

&lt;bean id="jaxbProviderSoap" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"/&gt;
</pre>
</div></div><p>This option is similar to the one involving wrapping CXF DataBindings as JAX-RS providers and using them for handling the data for the JAX-RS endpoints. This time though it is SOAP endpoints which are relying on the JAX-RS providers to handle the data properly.</p><p>If you would like to write your own custom XML provider and have it wrapped by the JAXRSDataBinding then custom MessageBodyReader and MessageBodyWriter implementations should be ready to accept null InputStream and OutputStream parameters and retrieve XMLStreamReader and XMLStreamWriter instances from the current CXF Message. To make the custom provider as portable as possible, one may want to follow the following approach :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class PortableXMLProvider implements MessageBodyReader, MessageBodyWriter {

    public Object readFrom(Class&lt;Object&gt; type, Type genericType, Annotation[] anns, MediaType mt, 
                           MultivaluedMap&lt;String, String&gt; headers, InputStream is) 
                           throws IOException {

        XMLStreamReader reader = createReaderUsingStandardStaxApi(is);
        return readFromStream(reader);  

    }

    public void writeTo(Object obj, Class&lt;?&gt; cls, Type genericType, Annotation[] anns,  
                        MediaType m, MultivaluedMap&lt;String, Object&gt; headers, OutputStream os)
                        throws IOException {
        XMLStreamWriter writer = createWriterUsingStandardStaxApi(os);
        writeToStream(writer);  
    }

    // add more parameters if needed
    protected Object readFromStream(XMLStreamReader reader) {
        // read from XMLStreamReader
    }
    
    // add more parameters if needed
    protected void writeToStream(XMLStreamWriter writer) {
        // write to XMLStreamWriter
    }

    
}

public class CXFCustomXMLProvider extends PortableXMLProvider {

    @Override
    public Object readFrom(Class&lt;Object&gt; type, Type genericType, Annotation[] anns, MediaType mt, 
                           MultivaluedMap&lt;String, String&gt; headers, InputStream is) 
                           throws IOException {

        XMLStreamReader reader = getStaxHandlerFromCurrentMessage(XMLStreamReader.class);
        return readFromStream(reader);  

    }

    @Override
    public void writeTo(Object obj, Class&lt;?&gt; cls, Type genericType, Annotation[] anns,  
                        MediaType m, MultivaluedMap&lt;String, Object&gt; headers, OutputStream os)
                        throws IOException {
        XMLStreamWriter writer = getStaxHandlerFromCurrentMessage(XMLStreamWriter.class);
        writeToStream(writer);  
    }


    protected &lt;T&gt; T getStaxHandlerFromCurrentMessage(Class&lt;T&gt; staxCls) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        if (m != null) {
            return staxCls.cast(m.getContent(staxCls));
        }
        return null;
    }
}
</pre>
</div></div><p>Please note that if you need the advanced DataBinding support for your JAX-WS endpoints (such as the schema validation with the schemas being available in the WSDL documents - likely to be supported, un-wrapping the XML payloads into multiple method parameters) then you are recommended to use one of the CXF DataBindings supported by CXF JAX-WS endpoints directly.</p><p>If all the resource methods have a single parameter such as a valid JAXB class and a response type which is not expected to be wrapped then it is likely this approach will work.</p><p>When using a CXF JAX-RS JAXBElementProvider, you may need to tune it to properly handle JAXB classes without XmlRootElement annotations and optionally create a single JAXBContext, something that CXF JAXBDataBinding does automatically. Also note that JAXBElementProvider is not aware that in some cases the local name of the first method parameter is "arg0" for SOAP requests and the local name of the SOAP response is expected to be "return". You may need to use JAX-WS WebParam and WebResult annotations to create different names; alternatively, you can use JAXBElementProvider's inTransformElements and outTransformElements properties, for example, to have 'arg0' converted to a bean name such as 'User' and 'User' converted to 'return'.</p><h1 id="JAXRSDataBindings-Schemavalidation">Schema validation</h1><p><strong>New</strong>: starting from CXF 3.0.0-milestone2 it is possible to point only to classpath folders containing multiple schema resources.</p><p>Schema validation can be enabled in one of the following ways:</p><p>1. Using jaxrs:schemaLocations element</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans&gt;
    &lt;jaxrs:server address="/" serviceClass="org.apache.cxf.systest.jaxrs.BookStore"&gt;
        &lt;jaxrs:schemaLocations&gt;
             &lt;jaxrs:schemaLocation&gt;classpath:/schemas/a.xsd&lt;/jaxrs:schemaLocation&gt;
             &lt;jaxrs:schemaLocation&gt;classpath:/schemas/b.xsd&lt;/jaxrs:schemaLocation&gt;
             &lt;!-- Possible from CXF 3.0.0 milestone2: --&gt;
             &lt;!-- 
                 &lt;jaxrs:schemaLocation&gt;classpath:/schemas/&lt;/jaxrs:schemaLocation&gt;
             --&gt;  
        &lt;/jaxrs:schemaLocations&gt;
    &lt;/jaxrs:server&gt;
&lt;/beans&gt;
</pre>
</div></div><p>Using this option is handy when you have multiple bindings involved which support the schema validation. In this case individual MessageBodyReader implementations which have a method setSchemas(List&lt;Sring&gt; schemaLocations) have it called and locations to schema resources injected. Default JAXBElementProvider and JSONProvider which rely on JAXB can be enabled to do the validation this way. In the above example two schema documents are provided, with b.xsd schema importing a.xsd</p><p>2. Configuring providers individually</p><p>JAXB and JSON providers can be configured explicitly, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
   &lt;jaxrs:server address="/" serviceClass="org.apache.cxf.systest.jaxrs.BookStore"&gt;
       &lt;jaxrs:providers&gt;
           &lt;ref bean="jaxbProvider"/&gt;
       &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;

    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
        &lt;property name="schemaLocations" ref="schemaHolder"/&gt;
    &lt;/bean&gt;
  
    &lt;util:list id="theSchemas"&gt;
        &lt;value&gt;classpath:/WEB-INF/schemas/bookid.xsd&lt;/value&gt;
        &lt;value&gt;classpath:/org/apache/cxf/systest/jaxrs/resources/book.xsd&lt;/value&gt;
    &lt;/util:list&gt;
&lt;/beans&gt;
</pre>
</div></div><p>If you have both JAXB and JSON providers validating the input data then you can get schemas shared between them, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
    &lt;jaxrs:server address="/" serviceClass="org.apache.cxf.systest.jaxrs.BookStore"&gt;
        &lt;jaxrs:providers&gt;
            &lt;ref bean="jaxbProvider"/&gt;
            &lt;ref bean="jsonProvider"/&gt;
        &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;

    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
        &lt;property name="schemaHandler" ref="schemaHolder"/&gt;
    &lt;/bean&gt;

    &lt;bean id="jsonProvider" class="org.apache.cxf.jaxrs.provider.json.JSONProvider"&gt;
        &lt;property name="schemaHandler" ref="schemaHolder"/&gt;
    &lt;/bean&gt;
  
    &lt;bean id="schemaHolder" class="org.apache.cxf.jaxrs.utils.schemas.SchemaHandler"&gt;
        &lt;property name="schemas" ref="theSchemas"/&gt;
    &lt;/bean&gt;
  
    &lt;util:list id="theSchemas"&gt;
        &lt;value&gt;classpath:/WEB-INF/schemas/bookid.xsd&lt;/value&gt;
        &lt;value&gt;classpath:/org/apache/cxf/systest/jaxrs/resources/book.xsd&lt;/value&gt;
    &lt;/util:list&gt;
&lt;/beans&gt;
</pre>
</div></div><p>3. Using SchemaValidation annotation&#160;</p><p>Starting from CXF 3.0.0 it is possible to use org.apache.cxf.annotations.SchemaValidation with JAX-RS root resources. Set its optional "schemas" property.</p><h2 id="JAXRSDataBindings-Supportforcatalogs">Support for catalogs</h2><p>Available starting from CXF 2.5.5, 2.6.2</p><p>XML Catalogs can be used for the main schema (which is used to validate the data) to get the imported or included schema resources resolved locally.<br clear="none">By default, a "META-INF/jax-rs-catalog.xml" will be checked however the catalog location can be set either on JAXBElementProvider or JSONProvider:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
   &lt;property name="catalogLocation" value="classpath:/schemas/mycatalog.xml"/&gt;
&lt;/bean&gt;
</pre>
</div></div><p>where mycatalog.xml may look like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog" prefer="system"&gt;
    &lt;system systemId="http://schemas/bookid.xsd" uri="classpath:WEB-INF/schemas/bookid.xsd"/&gt;
&lt;/catalog&gt;
</pre>
</div></div><h2 id="JAXRSDataBindings-Outputvalidation">Output validation</h2><p>By default, after a valid schema has been located, only JAXB Unmarshaller will use it to validate the input.<br clear="none">Starting from CXF 2.3.4 and 2.4, the following properties can be used to enable the output validation:</p><ul class="alternate"><li>validateOutput</li><li>validateBeforeWrite</li></ul><p>Setting the 'validateOutput' property will ensure that JAXBMarshaller will validate the output while writing the data. The 'validateBeforeWrite' property can be set to ensure the validation is done before data are written to the output stream.</p><h1 id="JAXRSDataBindings-BeanValidation">Bean Validation</h1><p>Bean Validation can be used to complement the schema validation or as an alternative form of validation, please see <a shape="rect" href="http://cxf.apache.org/docs/validationfeature.html">this page</a> for more information.</p><h1 id="JAXRSDataBindings-FastInfoset">Fast Infoset</h1><p>You can enable <a shape="rect" class="external-link" href="http://www.oracle.com/technetwork/articles/java/fastinfoset-139262.html" rel="nofollow">FastInfoset</a> by explicitly registering CXF FastInfoset interceptors with a JAXRS endpoint and configuring JAXBElementProvider to support an "application/fastinfoset" media type :<br clear="none">for example :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="restservice3" address="/rest3"&gt;

    &lt;jaxrs:serviceBeans&gt;
        &lt;ref bean="bookstore"/&gt;
    &lt;/jaxrs:serviceBeans&gt;

    &lt;jaxrs:providers&gt;
        &lt;ref bean="jaxbProvider"/&gt;
    &lt;/jaxrs:providers&gt;

    &lt;jaxrs:outInterceptors&gt;
        &lt;ref bean="fastInfosetOutInterceptor"/&gt;
    &lt;/jaxrs:outInterceptors&gt;

    &lt;jaxrs:inInterceptors&gt;
        &lt;ref bean="fastInfosetInInterceptor"/&gt;
    &lt;/jaxrs:inInterceptors&gt;

    &lt;jaxrs:properties&gt;
        &lt;entry key="org.apache.cxf.endpoint.private" value="true"/&gt;
    &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;

&lt;util:list id="fastinfosetType"&gt;
    &lt;value&gt;application/fastinfoset&lt;/value&gt;
&lt;/util:list&gt;

&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
    &lt;property name="produceMediaTypes" ref="fastinfosetType"/&gt;
    &lt;property name="consumeMediaTypes" ref="fastinfosetType"/&gt;
&lt;/bean&gt;
&lt;bean id="fastInfosetOutInterceptor" class="org.apache.cxf.interceptor.FIStaxOutInterceptor"/&gt;
&lt;bean id="fastInfosetInInterceptor" class="org.apache.cxf.interceptor.FIStaxInInterceptor"/&gt;
</pre>
</div></div><p>Note that explicitly registering the interceptors is not required anymore given that CXF FastInfoset and Feature annotations are also currently supported.</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </table>
   </td>
   <td id="cell-2-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
   <td id="cell-3-0">&nbsp;</td>
   <td id="cell-3-1">&nbsp;</td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">Privacy Policy</a> - 
         (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=24190800">edit page</a>) 
	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=24190800&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)<br>
	Apache CXF, CXF, Apache, the Apache feather logo are trademarks of The Apache Software Foundation.<br>
        All other marks mentioned may be trademarks or registered trademarks of their respective owners.
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3">&nbsp;</td>
   <td id="cell-3-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2">&nbsp;</td>
    <td id="cell-4-1">&nbsp;</td>
    <td id="cell-4-2" colspan="2">&nbsp;</td>
  </tr>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

