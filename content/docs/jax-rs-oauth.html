
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS OAuth">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>
Apache CXF -- JAX-RS OAuth
    </title>
  </head>
<body onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td id="cell-0-0" colspan="2">&nbsp;</td>
    <td id="cell-0-1">&nbsp;</td>
    <td id="cell-0-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-1-0">&nbsp;</td>
    <td id="cell-1-1">&nbsp;</td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight: bold; font-size: 170%; color: white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="The Apache Sofware Foundation"><img border="0" alt="ASF Logo" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs -->
<a href="index.html">Index</a>&nbsp;&gt;&nbsp;<a href="restful-services.html">RESTful Services</a>&nbsp;&gt;&nbsp;<a href="jax-rs.html">JAX-RS</a>&nbsp;&gt;&nbsp;<a href="jax-rs-oauth.html">JAX-RS OAuth</a>
                <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">Download</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">Documentation</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </table>
      </div>
    </td>
    <td id="cell-1-3">&nbsp;</td>
    <td id="cell-1-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2">&nbsp;</td>
    <td id="cell-2-1">
      <table>
        <tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">Overview</a></li><li><a shape="rect" href="how-tos.html">How-Tos</a></li><li><a shape="rect" href="frontends.html">Frontends</a></li><li><a shape="rect" href="databindings.html">DataBindings</a></li><li><a shape="rect" href="transports.html">Transports</a></li><li><a shape="rect" href="configuration.html">Configuration</a></li><li><a shape="rect" href="debugging-and-logging.html">Debugging and Logging</a></li><li><a shape="rect" href="tools.html">Tools</a></li><li><a shape="rect" href="restful-services.html">RESTful Services</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL Bindings</a></li><li><a shape="rect" href="service-routing.html">Service Routing</a></li><li><a shape="rect" href="dynamic-languages.html">Dynamic Languages</a></li><li><a shape="rect" href="ws-support.html">WS-* Support</a></li><li><a shape="rect" href="advanced-integration.html">Advanced Integration</a></li><li><a shape="rect" href="deployment.html">Deployment</a></li><li><a shape="rect" href="schemas-and-namespaces.html">Use of Schemas and Namespaces</a></li></ul><hr><ul class="alternate"><li><p>Search</p></li></ul><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF Website</a></li></ul><p>&#160;</p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><br clear="none"><span style="font-size:2em;font-weight:bold">JAX-RS: OAuth</span>


<br clear="none"></p><p><br clear="none"></p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1636141560470 {padding: 0px;}
div.rbtoc1636141560470 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1636141560470 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1636141560470">
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSOAuth-Introduction">Introduction</a></li><li><a shape="rect" href="#JAXRSOAuth-Mavendependencies">Maven dependencies</a></li><li><a shape="rect" href="#JAXRSOAuth-DevelopingOAuth1.0Servers">Developing OAuth 1.0 Servers</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSOAuth-RequestTokenService">RequestTokenService</a></li><li><a shape="rect" href="#JAXRSOAuth-AuthorizationRequestService">AuthorizationRequestService</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSOAuth-OOBcallbacks">OOB callbacks</a></li></ul>
</li><li><a shape="rect" href="#JAXRSOAuth-AccessTokenService">AccessTokenService</a></li><li><a shape="rect" href="#JAXRSOAuth-WritingOAuthDataProvider">Writing OAuthDataProvider</a></li><li><a shape="rect" href="#JAXRSOAuth-OAuthServerJAX-RSendpoints">OAuth Server JAX-RS endpoints</a></li></ul>
</li><li><a shape="rect" href="#JAXRSOAuth-ProtectingresourceswithOAuthfilters">Protecting resources with OAuth filters</a></li><li><a shape="rect" href="#JAXRSOAuth-Howtogettheuserloginname">How to get the user login name</a></li><li><a shape="rect" href="#JAXRSOAuth-Client-sidesupport">Client-side support</a></li><li><a shape="rect" href="#JAXRSOAuth-2-legOAuthFlow">2-leg OAuth Flow</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSOAuth-ClientrequestsPreAuthorizedRequestToken">Client requests PreAuthorized RequestToken</a></li><li><a shape="rect" href="#JAXRSOAuth-SignaturewithConsumerKeyandSecret">Signature with Consumer Key and Secret</a></li><li><a shape="rect" href="#JAXRSOAuth-OnlyConsumerKeyandSecretinAuthorizationheader">Only Consumer Key and Secret in Authorization header</a></li></ul>
</li><li><a shape="rect" href="#JAXRSOAuth-OAuthWithoutaBrowser">OAuth Without a Browser</a></li><li><a shape="rect" href="#JAXRSOAuth-Reportingtheerrordetails">Reporting the error details</a></li><li><a shape="rect" href="#JAXRSOAuth-Designconsiderations">Design considerations</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSOAuth-ControllingtheAccesstoResourceServer">Controlling the Access to Resource Server</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAXRSOAuth-Sharingthesameaccesspathbetweenendusersandconsumers">Sharing the same access path between end users and consumers</a></li><li><a shape="rect" href="#JAXRSOAuth-Providingdifferentaccesspointstoendusersandconsumers">Providing different access points to end users and consumers</a></li></ul>
</li><li><a shape="rect" href="#JAXRSOAuth-SingleSignOn">Single Sign On</a></li></ul>
</li><li><a shape="rect" href="#JAXRSOAuth-WhatIsNext">What Is Next</a></li></ul>
</div><div class="confluence-information-macro confluence-information-macro-warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>OAuth 1.0 support in CXF was dropped from the 3.5.0 release onwards</p></div></div><h1 id="JAXRSOAuth-Introduction">Introduction</h1><p>CXF 2.5.0 implements <a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc5849" rel="nofollow">OAuth 1.0</a>. Please also see the <a shape="rect" href="jax-rs-oauth2.html">JAX-RS OAuth2</a> about the OAuth2 support in CXF.</p><p>While <a shape="rect" class="external-link" href="http://oauth.net/2/" rel="nofollow">OAuth 2.0</a> (which is very close to becoming the final recommendation) is the next major version of OAuth, OAuth 1.0 has been implemented by many providers and the CXF OAuth 1.0 module should make it easy for developers to start writing OAuth 1.0 applications.</p><p>OAuth 1.0 offers a complex yet elegant solution toward helping the end users (resource owners) authorize third-party providers to access their resources.</p><p>The classical OAuth flow is also called a 3-leg OAuth flow as it involves 3 parties: the end user (resource owner), the third party service (client, consumer) and the resource server which is protected by OAuth filters. Typically a consumer offers a service feature that an end user requests and which requires the former to access one or more resources of this end user which are located at the resource server. For example, the consumer may need to access the end user's photos in order to print them and post to the user or read and possibly update a user's calendar in order to make a booking.</p><p>In order to make it happen, the third-party service application/consumer needs to register itself with the OAuth server. This happens out-of-band and after the registration the consumer gets back a consumer key and secret pair. For example, see this page for one <a shape="rect" class="external-link" href="http://code.google.com/apis/accounts/docs/RegistrationForWebAppsAuto.html" rel="nofollow">approach</a>. The registrations of third-party application does not have to be very involved for simpler applications.</p><p>From then on, the typical flow works like this:<br clear="none">1. End User requests the third-party service using a browser.</p><p>2. Third-party service requests a temporarily request token from OAuth RequestToken Service; this token will represent a consumer's intention to access whatever end user resources it needs to complete the current user's request.</p><p>3. After getting a request token back, the consumer redirects the end user to OAuth Authorization Service and adds the request token to the target URI.</p><p>4. Authorization Service will get all the details about the current consumer using a request token, build an HTML form and return it to the end user. The form will ask the user if a given third-party application can be allowed to access some resources on behalf of this user.</p><p>5. If the user approves it then Authorization Service will redirect the user back to the callback uri provided by the consumer when requesting a request token, including a generated verifier (authorization key) which 'links' the user's approval with the request token.</p><p>6. Now the third-party service requests an access token from OAuth AccessToken Service by providing a request token and its verifier.</p><p>7. After getting an access token, the service finally proceeds with accessing the current user's resources and completes the user's request.</p><p>As noted above, the consumer needs to register first with the OAuth server. It's a good practice to provide an application name and so called connect URI which is typically a public URI of this application; the former will be used by OAuth Authorization Service at step 4 above and the latter will be used at step 2 to validate the provided callback URI to make sure it starts from the URI which was actually provided during the registration.</p><p>As you can see the flow can be complex yet it is functional. A number of issues may need to be taken care along the way such as managing expired tokens, making sure that the OAuth security layer is functioning properly and is not interfering with the end user itself trying to access its own resources, etc.</p><p>Please check the <a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc5849" rel="nofollow">specification</a> and the <a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/OAuth" rel="nofollow">Wikipedia article</a> as well as other resources available on the WEB for more information you may need to know about OAuth.</p><p>CXF JAX-RS gives the best effort to making this process as simple as possible and requiring only a minimum effort on behalf of OAuth server developers. It also offers the utility code for greatly simplifying the way the third-party application can interact with the OAuth service endpoints.</p><h1 id="JAXRSOAuth-Mavendependencies">Maven dependencies</h1><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-rs-security-oauth&lt;/artifactId&gt;
  &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><h1 id="JAXRSOAuth-DevelopingOAuth1.0Servers">Developing OAuth 1.0 Servers</h1><p>OAuth server is the core piece of the complete OAuth-based solution. Typically it contains 3 services for:</p><ul class="alternate"><li>Initiating the flows by issuing temporarily tokens to consumers</li><li>Authorizing request tokens by asking the end users to let consumers access some of their resources and returning the<br clear="none">confirmation back to the consumer</li><li>Exchanging authorized request tokens for access tokens</li></ul><p>CXF offers 3 JAX-RS service implementations that can be used to create OAuth 1.0 servers fast: <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/RequestTokenService.java" rel="nofollow">RequestTokenService</a>, <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a> and <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AccessTokenService.java" rel="nofollow">AccessTokenService</a>.</p><p>All of these 3 services rely on the custom <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a> which manages request and access tokens. Writing your own OAuthDataProvider implementations is what is needed to get the OAuth server up and running.</p><h2 id="JAXRSOAuth-RequestTokenService">RequestTokenService</h2><p>The main responsibility of&#160;<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/RequestTokenService.java" rel="nofollow">RequestTokenService</a> is to create a temporarily request token and return it back to the consumer. It supports POST and GET requests and returns a form payload containing the new request token and its secret.</p><p>Here is an example request log:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/oauth/initiate
Encoding: ISO-8859-1
Http-Method: POST
Content-Type: */*
Headers: {
Accept=[application/x-www-form-urlencoded], 

Content-Length=[0],

Authorization=[OAuth oauth_callback="http%3A%2F%2Flocalhost%3A8080%2Fservices%2Freservations%2Freserve%2Fcomplete", 
                     oauth_nonce="e365fa02-772e-4e33-900d-00a766ccadf8", 
                     oauth_consumer_key="123456789", 
                     oauth_signature_method="HMAC-SHA1", 
                     oauth_timestamp="1320748683", 
                     oauth_version="1.0", 
                     oauth_signature="ztTQuqaJS7L6dNQwn%2Fqi1MdaqQQ%3D"] 
}
</pre>
</div></div><p>It is an empty POST request which includes an Authorization OAuth header. The value of the header has a consumer key (obtained during the third-party registration), callback URI pointing to where AuthorizationRequestService will return an authorized token and a signature which was calculated using a consumer key and secret pair as <a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc5849#section-3.4.2" rel="nofollow">described in the specification</a>.</p><p>First RequestTokenService validates the signature and then it retrieves a <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java">Client</a> instance from OAuthDataProvider using a consumer key.</p><p>Before asking OAuthDataProvider to generate a request token, it attempts to validate a callback URI against a <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">Client</a>'s application URI.</p><p>Finally it delegates to OAuthDataProvider to create a request token, passing to it a populated <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/RequestTokenRegistration.java" rel="nofollow">RequestTokenRegistration</a> bean.</p><p>This bean references a Client instance, callback URI and a state. State is something that a consumer may also include during the request token request using a "state" parameter and will be returned back to the consumer alongside the verifier after the request token has been authorized. For example, it may represent a key that a consumer will use to retrieve the state of the request that it was processing when requesting a token. For OAuth 1.0<br clear="none">consumers, the request token itself may represent a good enough key for such purposes, but "state" may need to be used too and will become more useful for OAuth 2.0.</p><p>The bean also includes "issuedAt" and "lifetime" values which represent the time a new token is about to be created and a configurable time in milliseconds that this token will 'live' for. OAuthDataProvider will be free to reset those values if needed before actually creating a request token.</p><p>Finally, one more property that may be set on this bean instance: list of scopes. List of scopes represents optional permissions that the consumer may need to access the resources. These can be provided by an "x_oauth_scope" ("scope" in OAuth 2.0) request parameter, for example,</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Authorization=[OAuth ..., 
                     x_oauth_scope="readCalendar updateCalendar"]
</pre>
</div></div><p>It's expected that each of the x_oauth_scope values such as "readCalendar" and "updateCalendar" are translated into <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermission</a>s during the creation of a new request token. If no x_oauth_scope parameter is provided then the OAuth data provider will likely assign a default OAuthPermission instance to the new token.</p><p>After a new request token has been created by OAuthDataProvider, RequestTokenService returns the token key and secret pair to the consumer:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 200
Content-Type: application/x-www-form-urlencoded
Headers: {Date=[Tue, 08 Nov 2011 10:38:03 GMT]}
Payload: 
oauth_callback_confirmed=true&amp;oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2&amp;oauth_token_secret=ca8273df-b9b0-43f9-9875-cfbb54ced550
</pre>
</div></div><p>The consumer is now ready to redirect the current end user to <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a>.</p><h2 id="JAXRSOAuth-AuthorizationRequestService">AuthorizationRequestService</h2><p>The main responsibility of AuthorizationRequestService is to present an end user with a form asking the user to allow or deny the consumer accessing some of the user resources.</p><p>Remember that a third-party consumer redirects the current user to <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a>, for example, here is how a redirection may happen:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 303
Headers: {Location=[http://localhost:8080/services/social/authorize?oauth_token=f4415e16-56ea-465f-9df1-8bd769253a7d]}
</pre>
</div></div><p>The consumer application asks the current user (the browser) to go to a new address provided by the Location header and the follow-up request to AuthorizationRequestService will look like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/social/authorize?oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2
Http-Method: GET
Content-Type: 
Headers: {
Accept=[text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8],   
Referer=[http://localhost:8080/services/forms/reservation.jsp], 
...
}
</pre>
</div></div><p>First,&#160;<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a> will retrieve <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/RequestToken.java" rel="nofollow">RequestToken</a> (which extends the base <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Token.java" rel="nofollow">Token</a> class) from OAuthDataProvider using the value provided by the "oauth_token" query parameter.</p><p>Next it uses this token (which also links to Client) to populate an instance of <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData</a> bean and returns it. OAuthAuthorizationData contains application name and URI properties, optional list of <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Permission.java" rel="nofollow">Permission</a>s and URIs.</p><p>Two other important OAuthAuthorizationData properties are "oauthToken" and "authenticityToken", both are important for processing the decision request coming from the authorization form. The former is a request token key which will be used by AuthorizationRequestService to retrieve the RequestToken again and the latter for validating that the current session has not been hijacked - AuthorizationRequestService generates a random key, stores it in a Servlet HTTPSession instance and expects the returned authenticityToken value to match it - this is a recommended approach and it also implies that the authenticityToken value is hidden from a user, for example, it's kept in a 'hidden' form field.</p><p>The helper "replyTo" property is an absolute URI identifying the AuthorizationRequestService handler processing the user decision and can be used by view handlers when building the forms or by other OAuthAuthorizationData handlers.</p><p>So the populated OAuthAuthorizationData is finally returned. Note that it's a JAXB XMLRootElement-annotated bean and can be processed by registered JAXB or JSON providers given that AuthorizationRequestService supports producing "application/xml" and "application/json" (See the OAuth Without Browser section below for more). But in this case we have the end user working with a browser so an HTML form is what is really expected back.</p><p>AuthorizationRequestService supports producing "text/html" and simply relies on a registered <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-redirection.html#JAX-RSRedirection-WithRequestDispatcherProvider">RequestDispatcherProvider</a> to set the OAuthAuthorizationData bean as an HttpServletRequest attribute and redirect the response to a view handler (can be JSP or some other servlet) to actually build the form and return it to the user. Alternatively, registering <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-advanced-xml.html#JAX-RSAdvancedXML-XSLTsupport">XSLTJaxbProvider</a> would also be a good option for creating HTML views.</p><p>Assuming RequestDispatcherProvider is used, the following example log shows the initial response from AuthorizationRequestService:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">08-Nov-2011 13:32:40 org.apache.cxf.jaxrs.provider.RequestDispatcherProvider logRedirection
INFO: Setting an instance of "org.apache.cxf.rs.security.oauth.data.OAuthAuthorizationData" 
as HttpServletRequest attribute "data" and redirecting the response to "/forms/oauthAuthorize.jsp".

08-Nov-2011 13:32:40 org.apache.cxf.interceptor.LoggingOutInterceptor
---------------------------
Response-Code: 200
Content-Type: text/html
</pre>
</div></div><p>Note that a "/forms/oauthAuthorize.jsp" view handler will create an HTML view - this is a custom JSP handler and whatever HTML view is required can be created there, using the OAuthAuthorizationData bean for building the view. Most likely you will want to present a form asking the user to allow or deny the consumer accessing some of this user's resources. If OAuthAuthorizationData has a list of Permissions set then adding the information about the permissions is needed, same for a list of URIs.</p><p>Next the user makes a decision and selects a button allowing or denying the consumer accessing the resources. AuthorizationRequestService does not need to know how a user has been asked to make the decision, but it expects to receive a form-based submission containing the following 3 parameters, named "session_authenticity_token" and "oauth_token" with values matching those of OAuthAuthorizationData's "authenticityToken" and "oauthToken" properties, and "oAuthDecision" with either "allow" or "deny" values:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/social/authorize/decision
Http-Method: POST
Content-Type: application/x-www-form-urlencoded
Headers: {
Authorization=[Basic YmFycnlAc29jaWFsLmNvbToxMjM0],
Cookie=[JSESSIONID=eovucah9rwqp], 
Referer=[http://localhost:8080/services/social/authorize?oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2], 
User-Agent=[Mozilla/5.0 (X11; Linux x86_64; rv:2.0) Gecko/20100101 Firefox/4.0]}
--------------------------------------
09-Nov-2011 16:41:58 org.apache.cxf.jaxrs.utils.FormUtils logRequestParametersIfNeeded
INFO: session_authenticity_token=e52b5033-9bf5-4b34-9d3a-39a7d5b7e686&amp;oauthDecision=allow
&amp;oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2
</pre>
</div></div><p>AuthorizationRequestService will use a session_authenticity_token to validate that the session is valid and will process the user decision next.<br clear="none">If it is set to "allow" then it will ask OAuthDataProvider to generate an authorization key (verifier) and return this verifier alongside with the request token key and the state if any by redirecting the current user back to the callback URI provided during the request token request:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 303
Headers: {
Location=[http://localhost:8080/services/reservations/reserve/complete?
oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2&amp;oauth_verifier=00bd8fa7-4233-42a2-8957-0a0a22c684ba]
}
</pre>
</div></div><p>which leads to a browser redirecting the user:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/reservations/reserve/complete?
oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2&amp;oauth_verifier=00bd8fa7-4233-42a2-8957-0a0a22c684ba
Http-Method: GET
Content-Type: 
Headers: {
Authorization=[Basic YmFycnlAc29jaWFsLmNvbToxMjM0], 
Cookie=[JSESSIONID=eovucah9rwqp],
Referer=[http://localhost:8080/services/social/authorize?oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2], 
User-Agent=[Mozilla/5.0 (X11; Linux x86_64; rv:2.0) Gecko/20100101 Firefox/4.0]}
</pre>
</div></div><p>If a user decision was set to "deny" then no verifier will be sent back to the consumer.</p><p>Assuming the decision was "allow", the consumer has now received back the request token and its verifier and is ready to exchange this pair for an access token.</p><h3 id="JAXRSOAuth-OOBcallbacks">OOB callbacks</h3><p>The OAuth 1.0 mentions so called "oob" (out-of-band) callbacks. If the third-party client is not running as a web application or if it is known it can not receive the redirect response from AuthorizationRequestService for whatever reasons, then a callback URI can be set to "oob", when a request token is <br clear="none">requested:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/oauth/initiate
Encoding: ISO-8859-1
Http-Method: POST
Content-Type: */*
Headers: {
Accept=[application/x-www-form-urlencoded], 

Content-Length=[0],

Authorization=[OAuth oauth_callback="oob", 
                     oauth_nonce="e365fa02-772e-4e33-900d-00a766ccadf8", 
                     oauth_consumer_key="123456789", 
                     oauth_signature_method="HMAC-SHA1", 
                     oauth_timestamp="1320748683", 
                     oauth_version="1.0", 
                     oauth_signature="ztTQuqaJS7L6dNQwn%2Fqi1MdaqQQ%3D"] 
}
</pre>
</div></div><p>RequestTokenService will only accept the "oob" value if a client callbackURI property has been set to "oob" during the client application registration process. Specifically, RequestTokenService will expect that a <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">Client</a> bean will have its callbackURI property being set to "oob".</p><p>When a callback URI is set to "oob", it means that a user decision response needs to be presented directly to the current user - which will then make the request token and verifier info somehow available to the client application. In case of "oob", AuthorizationRequestService, instead of redirecting the user back to the callback URI as shown earlier on, will simply return an instance of <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/OOBAuthorizationResponse.java" rel="nofollow">OOBAuthorizationResponse</a>. RequestDispatcherProvider will need to be used for redirecting this data to the view handler exactly how it is done when a user is asked to authorize the client application, with the view handler formatting the data and actually returning it to the user</p><h2 id="JAXRSOAuth-AccessTokenService">AccessTokenService</h2><p>The role of AccessTokenService is to exchange an authorized request token for a new access token which will be used by the consumer to access the end user's resources. <br clear="none">Here is an example request log:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/oauth/token
Http-Method: POST
Headers: {
Accept=[application/x-www-form-urlencoded], 
Authorization=[OAuth oauth_signature_method="HMAC-SHA1", 
                     oauth_consumer_key="123456789", 
                     oauth_token="6dfd5e52-236c-4939-8df8-a53212f7d2a2", 
                     oauth_verifier="00bd8fa7-4233-42a2-8957-0a0a22c684ba", 
                     oauth_timestamp="1320760259", 
                     oauth_nonce="16237669362301", 
                     oauth_version="1.0", 
                     oauth_signature="dU%2BhXPNFfFpX2sC74IOxzTjdVrY%3D"]
}
</pre>
</div></div><p>This request is very similar to a temporarily token request. Note that the request token key is also included and this token key and its secret pair, as well as the consumer key and secret pair are used to calculate the signature.</p><p>AccessTokenService validates the signature, asks OAuthDataProvider to remove a RequestToken identified by the "oauth_token" and compares the "oauth_verifier" value against the one stored in this RequestToken.</p><p>Note that if the "oauth_verifier" is missing then AccessTokenService will check that RequestToken has been preauthorized and that its UserSubject property is initialized. If both conditions are met then the access token request is allowed to continue.</p><p>Next it asks the data provider to create a new <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/AccessToken.java" rel="nofollow">AccessToken</a> based on this RequestToken. The resulting access token key and secret pair is returned back to a consumer:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 200
Content-Type: application/x-www-form-urlencoded
Headers: {Date=[Tue, 08 Nov 2011 13:50:59 GMT]}
Payload: oauth_token=abc15aca-2073-4bde-b1be-1a02dc7ccafe&amp;oauth_token_secret=859dfe9e-ca4c-4b36-9e60-044434ab636c
</pre>
</div></div><p>The consumer will use this access token to access the current user's resources in order to complete the original user's request, for example, the request to access a user's calendar may look like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[OAuth oauth_signature_method="HMAC-SHA1", 
                     oauth_consumer_key="123456789", 
                     oauth_token="abc15aca-2073-4bde-b1be-1a02dc7ccafe", 
                     oauth_version="1.0", 
                     oauth_signature="dU%2BhXPNFfFpX2sC74IOxzTjdVrY%3D"]
}
</pre>
</div></div><p>Note that the access token is set and the access token key and secret pair, as well as the consumer key and secret pair are used to create a signature.</p><h2 id="JAXRSOAuth-WritingOAuthDataProvider">Writing OAuthDataProvider</h2><p>Using CXF OAuth service implementations will help a lot with setting up an OAuth server. As you can see from the above sections, these services rely on a custom <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a> implementation.</p><p>The main task of OAuthDataProvider is to persist request and access tokens and generate authorization/verifier keys. The way it's done is really application-specific. Consider starting with a basic memory based implementation and then move on to keeping the data in some DB.</p><p>Note that OAuthDataProvider supports retrieving <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">Client</a> instances but it has no methods for creating or removing Clients. The reason for it is that the process of registering third-party consumers is very specific to a particular OAuth application, so CXF does not offer a registration support service and hence OAuthDataProvider has no Client create/update methods. You will likely need to do something like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class CustomOAuthProvider implements OAuthDataProvider {
   public Client registerClient(String applicationName, String applicationURI, ...) {}
   public void removeClient(String cliendId) {}
   // etc
   // OAuthDataProvider methods
}
</pre>
</div></div><p>CustomOAuthProvider will also remove all tokens associated with a given Client in removeClient(String cliendId).</p><p>When creating RequestToken or AccessToken tokens as well as authorization keys, OAuthDataProvider will need to create unique identifiers.<br clear="none">The way it's done is application specific and custom implementations may also use a utility <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/provider/MD5SequenceGenerator.java" rel="nofollow">MD5SequenceGenerator</a> shipped with CXF, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public String setRequestTokenVerifier(RequestToken requestToken) throws OAuthServiceException {
    requestToken.setVerifier(generateSequence());
    return requestToken.getVerifier();
}

private String generateSequence() throws OAuthServiceException {
    try {
       return tokenGenerator.generate(UUID.randomUUID().toString().getBytes("UTF-8"));
    } catch (Exception e) {
       throw new OAuthServiceException("Unable to generate the key", e.getCause());
    }
}

</pre>
</div></div><p>Generating tokens/keys and persisting them effectively is what OAuthDataProvider all about.<br clear="none">Note that CXF will check that Request and Access tokens have not expired every time it uses them and will ask OAuthDataProvider to remove the expired tokens, but the custom OAuthDataProvider implementation may do its own checks too.</p><p>Finally OAuthDataProvider may need to convert opaque scope values such as "readCalendar" into a list of <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermission</a>s. AuthorizationRequestService and OAuth security filters will depend on it (assuming scopes are used in the first place). In the former case AuthorizationRequestService will use this list to populate <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData</a> - the reason this bean only sees <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Permission.java" rel="nofollow">Permission</a>s is that the properties OAuthPermission keeps are of no interest to OAuthAuthorizationData handlers.</p><h2 id="JAXRSOAuth-OAuthServerJAX-RSendpoints">OAuth Server JAX-RS endpoints</h2><p>With CXF offering OAuth service implementations and a custom OAuthAuthorizationData provider in place, it is time to deploy the OAuth server. <br clear="none">Most likely, you'd want to deploy RequestTokenService and AccessTokenService as two root resources inside a single JAX-RS endpoint (or have one RequestTokenService and one AccessTokenService endpoint), for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;!-- implements OAuthDataProvider --&gt;
&lt;bean id="oauthProvider" class="oauth.manager.OAuthManager"/&gt;

&lt;bean id="requestTokenService" class="org.apache.cxf.rs.security.oauth.services.RequestTokenService"&gt;
   &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;
     
&lt;bean id="accessTokenService" class="org.apache.cxf.rs.security.oauth.services.AccessTokenService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;jaxrs:server id="oauthServer" address="/oauth"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="requestTokenService"/&gt;
      &lt;ref bean="accessTokenService"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>RequestTokenService listens on a relative "/initiate" path, AccessTokenService - on "/token". Giving the that jaxrs:server/@adress is "/oauth" and assuming a context name is "/services", the absolute address of RequestTokenService would be something like "http://localhost:8080/services/oauth/initiate" and that of AccessTokenService - "http://localhost:8080/services/oauth/token".</p><p>AuthorizationRequestService is better to put where the main application endpoint is. It can be put alongside RequestTokenService and AccessTokenService - but the problem is that the end user is expected to authenticate itself with the resource server after it has been redirected by a third-party consumer to AuthorizationRequestService. That would make it more complex for the OAuth server endpoint to manage both OAuth (third-party consumer) and the regular user authentication - that can be done, see more on it below in the Design considerations section, but the simpler option is to simply get AuthorizationRequestService under the control of the security filter enforcing the end user authentication:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="authorizationService" class="org.apache.cxf.rs.security.oauth.services.AuthorizationRequestService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;bean id="myApp" class="org.myapp.MyApp"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;jaxrs:server id="oauthServer" address="/myapp"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="myApp"/&gt;
      &lt;ref bean="authorizationService"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>AuthorizationRequestService listens on a relative "/authorize" path so in this case its absolute address will be something like "http://localhost:8080/services/myapp/authorize". This address and those of RequestTokenService and AccessTokenService will be used by third-party consumers.</p><h1 id="JAXRSOAuth-ProtectingresourceswithOAuthfilters">Protecting resources with OAuth filters</h1><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/filters/OAuthRequestFilter.java" rel="nofollow">OAuthRequestFilter</a> request handler can be used to protect the resource server when processing the requests from the third-party consumers. Add it as a jaxrs:provider to the endpoint which deals with the consumers requesting the resources.</p><p>When checking a request like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[OAuth oauth_signature_method="HMAC-SHA1", 
                     oauth_consumer_key="123456789", 
                     oauth_token="abc15aca-2073-4bde-b1be-1a02dc7ccafe", 
                     oauth_version="1.0", 
                     oauth_signature="dU%2BhXPNFfFpX2sC74IOxzTjdVrY%3D"]
}
</pre>
</div></div><p>the filter will do the following:</p><p>1. It will validate the signature and will get Client and AccessToken from OAuthDataProvider.</p><p>2. It will check if <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/AccessToken.java" rel="nofollow">AccessToken</a> have a "uris" property set and if yes then it will validate the current request URI against it.</p><p>3. If AccessToken has a list of <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermissions</a>. For every permission it will:</p><ul class="alternate"><li>If it has a uri property set then the current request URI will be checked against it</li><li>If it has an httpVerb property set then the current HTTP verb will be checked against it</li></ul><p>4. Finally, it will create a CXF SecurityContext using this list of <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermissions</a> and the <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">Client</a> loginName property.</p><p>This loginName property is something that can be optionally associated with the new Client during the registration - if it is not set then the filter will use a Client "applicationName" property instead. The application code checking the user Principal will see the chosen value. Additionally every OAuthPermission may have a list of application-specific roles such as "consumer", etc, which will be added to SecurityContext and will be checked during SecurityContext.isUserInRole(roleName) calls.</p><p>If a "useUserSubject" property is set on the filter then a UserSubject associated with the access token will be used to populate the SecurityContext.</p><p>This SecurityContext will not necessarily be important for some of OAuth applications. Most of the security checks will be done by OAuth filters and security filters protecting the main application path the end users themselves use. Only if you would like to share the same JAX-RS resource code and access URIs between end users and consumers then it can become handy. More on it below.</p><p>Note that <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/filters/OAuthServletFilter.java" rel="nofollow">OAuthServletFilter</a> can be deployed instead. It will need the OAuthDataProvider full class name referenced as an "oauth.data.provider-class" servlet context parameter.</p><h1 id="JAXRSOAuth-Howtogettheuserloginname">How to get the user login name</h1><p>When one writes a custom server application which needs to participate in 3-leg OAuth flows, the major question which needs to be addressed is<br clear="none">how one can access a user login name that was used during the end-user authorizing the third-party client. This username will help to uniquely identify the resources that the 3rd party client is now attempting to access.<br clear="none">The following code shows one way of how this can be done starting from CXF 2.5.1:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> 
@Path("/userResource")
public class ThirdPartyAccessService {

    @Context 
    private MessageContext mc;
	
    @GET
    public UserResource getUserResource() {
        OAuthContext oauth = mc.getContent(OAuthContext.class);
        if (oauth == null || oauth.getSubject() == null || oauth.getSubject().getLogin() == null) {
	   throw new WebApplicationException(403);
	}
	String userName = oauth.getSubject().getLogin();
	return findUserResource(userName)
    }

    private UserResource findUserResource(String userName) {
        // find and return UserResource
    }
}

</pre>
</div></div><p>The above shows a fragment of the JAX-RS service managing the access to user resources from authorized 3rd-party clients (see the Design Considerations section for more information).</p><p>The injected MessageContext provides an access to <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthContext.java" rel="nofollow">OAuthContext</a> which has been set by OAuth filters described in the previous section. OAuthContext will act as a container of the information which can be useful to the custom application code which do not need to deal with the OAuth internals which will likely change between OAuth 1.0 and OAuth 2.0. At the moment OAuthContext provides an access to <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/UserSubject.java" rel="nofollow">UserSubject</a> which is created by CXF AuthorizationService at the moment of the end user authorizing the third-party client and captures the end user's login name (and roles which will be available if CXF JAASLoginInterceptor is used to authenticate end users) and associates it with the current <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/RequestToken.java" rel="nofollow">RequestToken</a>. It will be a responsibility of custom OAuthDataProviders to make sure this UserSubject bean is copied across to a corresponding <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/AccessToken.java" rel="nofollow">AccessToken</a>. OAuthContext also references the list of the permissions which have been validated againt the current client request.</p><p>Additionally you may get OAuth filters to set up a SecurityContext which will use the information available in <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/UserSubject.java" rel="nofollow">UserSubject</a>, in other words, get the 3rd-party client impersonating the end user (which authorized this client in the first place) for the duration of the current request. Set a jaxrs contextual "org.apache.cxf.rs.security.oauth.use_user_subject" property to 'true' for this to happen.</p><h1 id="JAXRSOAuth-Client-sidesupport">Client-side support</h1><p>When developing a third party application which needs to participate in OAuth flows one has to write the code that will redirect users to OAuth AuthorizationRequestService, interact with RequestTokenService and AccessTokenService in order to get request and access tokens as well as correctly build Authorization OAuth headers when accessing the end users' resources. JAX-RS makes it straightforward to support the redirection, while <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/client/OAuthClientUtils.java" rel="nofollow">OAuthClientUtils</a> class makes it possible to encapsulate most of the complexity away from the client application code.</p><p>OAuthClientUtils has utility methods for getting request and access tokens, the consumer is expected to provide a properly initialized WebClient pointing to either RequestTokenService and AccessTokenService, Consumer bean containing the registration key and secret, a callback URI for requesting a request token and the request Token and the verifier for requesting the access token which is all quite straightforward. It also helps to create a proper URI for redirecting to AuthorizationRequestService. A correct Authorization header will also need to be used when accessing the user resources at the resource server and OAuthClientUtils will help with creating this header as well.</p><p>For example, the following custom code can be used by the third-party application:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class OAuthClientManager {
	
	private WebClient accessTokenService;
        private WebClient requestTokenService;
        private String authorizationServiceURI;
    
        // inject properties...
	
	public URI getAuthorizationServiceURI(String token) {
	    return OAuthClientUtils.getAuthorizationURI(authorizationServiceURI, token);
	}
	
	public Token getRequestToken(URI callback) {
	    try {
	        return OAuthClientUtils.getRequestToken(requestTokenService, consumer, callback, null);
	    } catch (OAuthServiceException ex) {
               return null;
            }    
	}
	
	public Token getAccessToken(Token requestToken, String verifier) {
	    try {
	        return OAuthClientUtils.getAccessToken(accessTokenService, consumer, requestToken, verifier);
	    } catch (OAuthServiceException ex) {
	        return null;
	    }
	}
	
	public String createAuthorizationHeader(Token token, String method, String requestURI) {
            return OAuthClientUtils.createAuthorizationHeader(consumer, token, method, requestURI);
	}
}
</pre>
</div></div><p>The reason such a simple wrapper can be introduced is to minimize the exposure to OAuth of the main application code to the bare minimum, this is why in this example OAuthServiceExceptions are caught, presumably logged and null values are returned which will indicate to the main code that the request failed. Obviously, OAuthClientUtils can be used directly as well.</p><h1 id="JAXRSOAuth-2-legOAuthFlow">2-leg OAuth Flow</h1><p>Please see this blog <a shape="rect" class="external-link" href="http://blog.nerdbank.net/2011/06/what-is-2-legged-oauth.html" rel="nofollow">entry</a> for a good overview of the OAuth 2-leg flow.<br clear="none">Here are the variations of the 2-leg flow that CXF supports:</p><h2 id="JAXRSOAuth-ClientrequestsPreAuthorizedRequestToken">Client requests PreAuthorized RequestToken</h2><p>In this variation the client accesses the request token as usual but skips the explicit authorization step.<br clear="none">Instead, after the request token has been obtained, it requests the access token without providing an "oauth_verifier" parameter. <br clear="none">For this to work RequestToken needs to be pre-authorized and have its UserSubject property set.</p><p>This is the only distinction from the typical 3-OAuth flow. OAuth filters will validate the request as usual.</p><h2 id="JAXRSOAuth-SignaturewithConsumerKeyandSecret">Signature with Consumer Key and Secret</h2><p>In this mode the consumer key and secret pairs are used to create the "oauth_signature", Authorization header will look pretty much the same as it does during RequestToken requests.</p><p>In this mode the Client is expected to reference a pre-authorized AccessToken. OAuth filters validate this token as usual.</p><h2 id="JAXRSOAuth-OnlyConsumerKeyandSecretinAuthorizationheader">Only Consumer Key and Secret in Authorization header</h2><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> 
Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[OAuth oauth_consumer_key="123456789",oauth_consumer_secret="987654321"] 
}
</pre>
</div></div><p>Alternatively, the consumer key and secret can be joined by a ":" character and encoded with the Base64 encoding:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> 
Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[Basic base64EncodedValue] 
}
</pre>
</div></div><p>In this mode the Client is expected to reference a pre-authorized AccessToken. OAuth filters validate this token as usual.</p><h1 id="JAXRSOAuth-OAuthWithoutaBrowser">OAuth Without a Browser</h1><p>When an end user is accessing the 3rd party application and is authorizing it later on, it's usually expected that the user is relying on a browser. <br clear="none">However, supporting other types of end users is easy enough. Writing the client code that processes the redirection requests from the 3rd party application and AuthorizationRequestService is simple with JAX-RS and additionally CXF can be configured to do auto-redirects on the client side.</p><p>Also note that AuthorizationRequestService can return XML or JSON <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData</a> representations. That makes it easy for a client code to get OAuthAuthorizationData and offer a pop-up window or get the input from the command-line. Authorizing the third-party application might even be automated in this case - which can lead to a complete 3-leg OAuth flow implemented without a human user being involved.</p><h1 id="JAXRSOAuth-Reportingtheerrordetails">Reporting the error details</h1><p>CXF OAuth 1.0 services will report only HTTP status code in case of various OAuth-related errors to minimize the information about the actual cause of the failure and will log the details locally. If providing the extra error information can help with debugging 3rd-party applications or if such application can indeed recover from the failures based on such details, then setting a contextual "report.failure.details" property to "true" will get the error messages available in the response body. Some OAuth1.0 implementers have chosen to return a custom "oauth_problem" HTTP header instead - this option can be supported by additionally setting a contextual "report.failure.details.as.header" property to "true", for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="oauthServer" address="/initiate"&gt;
        &lt;jaxrs:serviceBeans&gt;
            &lt;bean class="org.apache.cxf.rs.security.oauth.services.RequestTokenService"/&gt;
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:properties&gt;
           &lt;entry key="report.failure.details" value="true"/&gt;
           &lt;entry key="report.failure.details.as.header" value="true"/&gt;
        &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;

</pre>
</div></div><h1 id="JAXRSOAuth-Designconsiderations">Design considerations</h1><p>This section will talk about various design considerations one need to take into account when deploying OAuth-based solutions.</p><h2 id="JAXRSOAuth-ControllingtheAccesstoResourceServer">Controlling the Access to Resource Server</h2><p>One of the most important issues one need to resolve is how to partition a URI space of the resource server application.</p><p>We have two different parties trying to access it, the end users which access the resource server to get to the resources which they own and 3rd party consumers which have been authorized by the end users to access some of their resources.</p><p>In the former case the way the authentication is managed is completely up to the resource server application: basic authentication, two-way TLS, OpenId (more on it below), you name it.</p><p>In the latter case an OAuth filter must enforce that the 3rd party consumer has been registered using the provided consumer key and that it has a valid access token (authorization key in OAuth 2.0) which represents the end user's approval. It's kind of the authentication and the authorization check at the same time.</p><p>Letting both parties access the resource server via the same URI(s) complicates the life for the security filters but all the parties are only aware of the single resource server URI which all of them will use.</p><p>Providing different access points to end users and consumers may significantly simplify the authentication process - the possible downside is that multiple access points need to be mantained by the resource server.</p><p>Both options are discussed next.</p><h3 id="JAXRSOAuth-Sharingthesameaccesspathbetweenendusersandconsumers">Sharing the same access path between end users and consumers</h3><p>The first problem which needs to be addressed is how to distinguish end users from third-party consumers and get both parties authenticated as required.<br clear="none">Perhaps the simplest option is to extend a CXF OAuth filter (JAX-RS or servlet one), check Authorization header, if it is OAuth then delegate to the superclass, alternatively - proceed with authenticating the end users:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class SecurityFilter extends org.apache.cxf.rs.security.oauth.filters.OAuthRequestFilter {
   @Context
   private HttpHeaders headers;

   public Response handleRequest(ClassResourceInfo cri, Message message) {
       String header = headers.getRequestHeaders().getFirst("Authorization");
       if (header.startsWith("OAuth ")) {
           return super.handleRequest(cri, message);
       } else {
           // authenticate the end user
       }
   }

} 
</pre>
</div></div><p>The next issue is how to enforce that the end users can only access the resources they've been authorized to access.<br clear="none">For example, consider the following JAX-RS resource class:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("calendar")
public class CalendarResource {

   @GET
   @Path("{id}")
   public Calendar getPublicCalendar(@PathParam("id") long id) {
       // return the calendar for a user identified by 'id'
   }

   @GET
   @Path("{id}/private")
   public Calendar getPrivateCalendar(@PathParam("id") long id) {
       // return the calendar for a user identified by 'id'
   }

   @PUT
   @Path("{id}")
   public void updateCalendar(@PathParam("id") long id, Calendar c) {
       // update the calendar for a user identified by 'id'
   }
}
</pre>
</div></div><p>Lets assume that the 3rd party consumer has been allowed to read the public user Calendars at "/calendar/{id}" only, how to make sure that the consumer won't try to:<br clear="none">1. update the calendar available at the same path <br clear="none">2. read the private Calendars available at "/calendar/{id}/private"</p><p>As noted above, Client, AccessToken (in its Token superclass) and OAuthPermission all have an optional URIs property. Thus one way to solve the problem with the private calendar is to add, say, a uri "/calendar/{id}" or "/calendar/1" (etc) property to OAuthPermission (representing a scope like "readCalendar") and the OAuth filter will make sure no subresources beyond "/calendar/{id}" can be accessed. Note, adding a "*" at the end of a given URI property, for example, "/a*" will let the consumer to access "/a", "/a/b", etc.</p><p>Solving the problem with preventing the update can be easily solved by adding an httpVerb property to a given OAuthPermission.</p><p>One more option is to rely on the role-based access control and have @RolesAllowed allocated such that only users in roles like "consumer" or "enduser" can invoke the getCalendar() method and let only those in the "enduser" role access getPrivateCalendar() and updateCalendar(). OAuthPermission can help here too as described in the section on using OAuth fiters.</p><h3 id="JAXRSOAuth-Providingdifferentaccesspointstoendusersandconsumers">Providing different access points to end users and consumers</h3><p>Rather than letting both the end users and 3rd party consumers use the same URI such as "http://myapp.com/service/calendars/{id}", one may want to introduce two URIs, one for end users and one for third-party consumers, for example, "http://myapp.com/service/calendars/{id}" - for endusers, "http://myapp.com/partners/calendars/{id}" - for the 3rd party consumers and deploy 2 jaxrs endpoints, where one is protected by the security filter checking the end users, and the one - by OAuth filters.</p><p>Additionally the endpoint managing the 3rd party consumers will deploy a resource which will offer a resticted URI space support. For example, if the application will only allow 3rd party consumers to read calendars then this resource will only have a method supporting @GET and "/calendar/{id}".</p><h2 id="JAXRSOAuth-SingleSignOn">Single Sign On</h2><p>When dealing with authenticating the end users, having an SSO solution in place is very handy. This is because the end user interacts with both the third-party and its resource server web applications and is also redirected from the consumer application to the resource server and back again. OpenID or say a <a shape="rect" href="http://cxf.apache.org/docs/saml-web-sso.html">WebBrowser SSO profile</a> can help.</p><h1 id="JAXRSOAuth-WhatIsNext">What Is Next</h1><p>Fine tuning the current OAuth 1.0 will be continued and the feedback from the implementers will be welcomed.</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </table>
   </td>
   <td id="cell-2-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
   <td id="cell-3-0">&nbsp;</td>
   <td id="cell-3-1">&nbsp;</td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">Privacy Policy</a> - 
         (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=27830330">edit page</a>) 
	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=27830330&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)<br>
	Apache CXF, CXF, Apache, the Apache feather logo are trademarks of The Apache Software Foundation.<br>
        All other marks mentioned may be trademarks or registered trademarks of their respective owners.
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3">&nbsp;</td>
   <td id="cell-3-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2">&nbsp;</td>
    <td id="cell-4-1">&nbsp;</td>
    <td id="cell-4-2" colspan="2">&nbsp;</td>
  </tr>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

